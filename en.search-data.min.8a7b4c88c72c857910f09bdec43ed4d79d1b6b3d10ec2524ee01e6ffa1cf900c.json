[{"id":0,"href":"/docs/architecture/","title":"Architecture","section":"Docs","content":"Architecture #   Introduction #  This document gives a high-level overview of chezmoi\u0026rsquo;s source code for anyone interested in contributing to chezmoi.\nYou can generate Go documentation for chezmoi\u0026rsquo;s source code with go doc, for example:\n$ go doc -all -u github.com/twpayne/chezmoi/v2/internal/chezmoi You can also browse chezmoi\u0026rsquo;s generated documentation online but this only includes exported symbols.\n Directory structure #  The important directories in chezmoi are:\n   Directory Contents     docs/ The documentation single source of truth. Help text, examples, and the chezmoi.io website are generated from the files in this directory, particularly docs/REFERENCE.md.   internal/chezmoi/ chezmoi\u0026rsquo;s core functionality.   internal/cmd/ Code for the chezmoi command.   internal/cmd/testdata/scripts/ High-level tests of chezmoi\u0026rsquo;s commands using testscript.     Key concepts #  As described in the reference manual, chezmoi evaluates the source state to compute a target state for the destination directory (typically your home directory). It then compares the target state to the actual state of the destination directory and performs any changes necessary to update the destination directory to match the target state. The concepts are represented directly in chezmoi\u0026rsquo;s code.\nchezmoi uses the generic term entry to describe something that it manages. Entries can be files, directories, symlinks, scripts, amongst other things.\n internal/chezmoi/ directory #  All of chezmoi\u0026rsquo;s interaction with the operating system is abstracted through the System interface. A System includes functionality to read and write files and directories and execute commands. chezmoi makes a distinction between idempotent commands that can be run multiple times without modifying the underlying system and arbitrary commands that may modify the underlying system.\nThe real underlying system is implemented via a RealSystem struct. Other Systems are composed on top of this to provide further functionality. For example, the --debug flag is implemented by wrapping the RealSystem with a DebugSystem that logs all calls to the underlying RealSystem. --dry-run is implemented by wrapping the RealSystem with a DryRunSystem that allows reads to pass through but silently discards all writes.\nThe SourceState struct represents a source state, including reading a source state from the source directory, executing templates, applying the source state (i.e. updating a System to match the desired source state), and adding more entries to the source state.\nEntries in the source state are abstracted by the SourceStateEntry interface implemented by the SourceStateFile and SourceStateDir structs, as the source state only consists of regular files and directories.\nA SourceStateFile includes a FileAttr struct describing the attributes parsed from its file name. Similarly, a SourceStateDir includes a DirAttr struct describing the directory attributes parsed from a directory name.\nSourceStateEntrys can compute their target state entries, i.e. what the equivalent entry should be in the target state, abstracted by the TargetStateEntry interface.\nActual target state entries include TargetStateFile structs, representing a file with contents and permissions, TargetStateDir structs, representing a directory, TargetStateSymlink for symlinks, TargetStateRemove for entries that should be removed, and TargetStateScript for scripts that should be run.\nThe actual state of an entry in the target state is abstracted via the ActualStateEntry interface, with ActualStateAbsent, ActualStateDir, ActualStateFile, ActualStateSymlink structs implementing this interface.\nFinally, an EntryState struct represents a serialization of an ActualEntryState for storage in and retrieval from chezmoi\u0026rsquo;s persistent state. It stores a SHA256 of the entry\u0026rsquo;s contents, rather than the full contents, to avoid storing secrets in the persistent state.\nWith these concepts, chezmoi\u0026rsquo;s apply command is effectively:\n Read the source state from the source directory. For each entry in the source state (SourceStateEntry), compute its TargetStateEntry and read its actual state in the destination state (ActualStateEntry). If the ActualStateEntry is not equivalent to the TargetStateEntry then apply the minimal set of changes to the ActualStateEntry so that they are equivalent.  Furthermore, chezmoi stores the EntryState of each entry that it writes in its persistent state. chezmoi can then detect if a third party has updated a target since chezmoi last wrote it by comparing the actual state entry in the target state with the entry state in the persistent state.\n internal/cmd/ directory #  internal/cmd/*cmd.go contains the code for each individual command and internal/cmd/*templatefuncs.go contain the template functions.\nCommands are defined as methods on the Config struct. The Config struct is large, containing all configuration values read from the config file, command line arguments, and computed and cached values.\nThe Config.persistentPreRunRootE and Config.persistentPostRunRootE methods set up and tear down state for individual commands based on the command\u0026rsquo;s Annotations field.\n Path handling #  chezmoi uses separate types for absolute paths (AbsPath) and relative paths (RelPath) to avoid errors where paths are combined (e.g. joining two absolute paths). A further type SourceRelPath is a relative path within the source directory and handles file and directory attributes.\nInternally, chezmoi normalizes all paths to use forward slashes with an optional upper-cased Windows volume so they can be compared with string comparisons. Paths read from the user may include tilde (~) to represent the user\u0026rsquo;s home directory, use forward or backward slashes, and are treated as external paths (ExtPath). These are normalized to absolute paths. chezmoi is case-sensitive internally and makes no attempt to handle case-insensitive or case-preserving filesystems.\n Persistent state #  Persistent state is treated as a two-level key-value store with the pseudo-structure map[Bucket]map[Key]Value, where Bucket, Key, and Value are all []bytes. The PersistentState interface defines interaction with them. Sometimes temporary persistent states are used. For example, in dry run mode (--dry-run) the actual persistent state is copied into a temporary persistent state in memory which remembers writes but does not persist them to disk.\n Encryption #  Encryption tools are abstracted by the Encryption interface that contains methods of encrypting and decrypting files and []bytes. Implementations are the AGEEncryption and GPGEncryption structs. A DebugEncryption struct wraps an Encryption interface and logs the methods called.\n run_once_ and run_onchange_ scripts #  The execution of a run_once_ script is recorded by storing the SHA256 of its contents in the scriptState bucket in the persistent state. On future invocations the script is only run if no matching contents SHA256 is found in the persistent state.\nThe execution of a run_onchange_ script is recorded by storing its target name in the entryState bucket along with its contents SHA256 sum. On future invocations the script is only run if its contents SHA256 sum has changed, and its contents SHA256 sum is then updated in the persistent state.\n Testing #  chezmoi has a mix of, unit, integration, and end-to-end tests. Unit and integration tests use the github.com/stretchr/testify framework. End-to-end tests use github.com/rogpeppe/go-internal/testscript with the test scripts themselves in testdata/scripts. You can run individual end-to-end tests with\n$ go test ./internal/cmd -run=TestScript/\u0026lt;name\u0026gt; where \u0026lt;name\u0026gt; is the basename of file in testdata/scripts.\nTests should, if at all possible, run unmodified on all operating systems tested in CI (Linux, macOS, Windows, and FreeBSD). Windows will sometimes need special handling due to its path separator and lack of POSIX-style file permissions.\n "},{"id":1,"href":"/docs/changes/","title":"Changes","section":"Docs","content":"Changes #   Overview #  This document describes what\u0026rsquo;s new in chezmoi v2 for chezmoi v1 users.\nIf you\u0026rsquo;re not using a dotfile manager, then read why you should you use a dotfile manager and then install chezmoi and follow the quick-start guide.\nIf you\u0026rsquo;re already using a dotfile manager, but not chezmoi, then read about how chezmoi compares to other dotfile managers first and then install chezmoi, follow the quick-start guide, and read the how-to guide to quickly discover chezmoi\u0026rsquo;s functionality.\n Version 2 #  chezmoi version 2 brings many new features and fixes a few corner-case bugs. Very few, if any, changes should be required to your source directory, templates, or config file.\n New features in version 2 #   The new chezmoi status command shows you a concise list of differences, much like git status. The chezmoi apply command prompts you if a file has been modified by something other than chezmoi since chezmoi last wrote it, keeping you in full control of your changes, wherever you make them. The chezmoi init command will try to guess your dotfile repository if you give it a short argument. For example, chezmoi init username is the equivalent of chezmoi init https://github.com/username/dotfiles.git. chezmoi includes a builtin git command which it will use if it cannot find git in your $PATH. This means that you don\u0026rsquo;t even have to install git to setup your dotfiles on a new machine. chezmoi detects when your config file template has changed and prompts you to re-run chezmoi init if needed. The new create_ attribute allows you to create a file with initial content, but not have it overwritten by chezmoi apply. The new modify_ attribute allows you to modify an existing file with a script, so you can use chezmoi to manage parts, but not all, of a file. The new script attributes before_ and after_ control when scripts are run relative to when your files are updated. The new --exclude option allows you to control what types of target will be updated. For example chezmoi apply --exclude=scripts will cause chezmoi to apply everything except scripts and chezmoi init --apply --exclude=encrypted will exclude encrypted files. The new --keep-going option causes chezmoi to keep going as far as possible rather than stopping at the first error it encounters. The new --no-tty option stops chezmoi from opening a TTY to read input (including passwords) and instead reads them from stdin. The new --source-path option allows you to specify targets by source path, which you can use in an on-save editor hook to automatically run chezmoi apply when you edit a dotfile in your source state. The new gitHubKeys template function allows you to populate your ~/.ssh/authorized_keys from your public SSH keys on GitHub. The promptBool function now also recognizes y, yes, on, n, no, and off as boolean values. The chezmoi archive command now includes scripts in the generated archive, and can generate .zip files. The new edit.command and edit.args configuration variables give you more control over the command invoked by chezmoi edit. The chezmoi init command has a new --one-shot option which does a shallow clone of your dotfiles repo, runs chezmoi apply, and then removes your source and configuration directories. It\u0026rsquo;s the fastest way to set up your dotfiles on a ephemeral machine and then remove all traces of chezmoi. Standard template variables are set on a best-effort basis. If errors are encountered, chezmoi leaves the variable unset rather than terminating with the error. The new .chezmoi.version template variable contains the version of chezmoi. You can compare versions using version comparison functions. The new .chezmoi.fqdnHostname template variables contains the fully-qualified domain name of the machine, if it can be determined. You can now encrypt whole files with age.   Changes from version 1 #  chezmoi version 2 includes a few minor changes from version 1, mainly to enable the new functionality and for consistency:\n chezmoi uses a different format to persist its state. Specifically, this means that all your run_once_ scripts will be run again the first time you run chezmoi apply. chezmoi add, and many other commands, are now recursive by default. chezmoi apply will warn if a file in the destination directory has been modified since chezmoi last wrote it. To force overwriting, pass the --force option. chezmoi edit no longer supports the --prompt option. The only diff format is now git. The diff.format configuration variable is ignored. Diffs include the contents of scripts that would be run. Mercurial support has been removed. The chezmoi source command has been removed, use chezmoi git instead. The sourceVCS configuration group has been renamed to git. The order of files for a three-way merge passed to merge.command is now actual file, target state, source state. The chezmoi keyring command has been moved to chezmoi secret keyring. The genericSecret configuration group has been renamed to secret. The chezmoi chattr command uses encrypted instead of encrypt as the attribute for encrypted files. The gpg recipient is configured with the gpg.recipient configuration variable, gpgRecipient is no longer used. The structure of data output by chezmoi dump has changed. The .chezmoi.homedir template variable has been replaced with .chezmoi.homeDir. For compatibility, .chezmoi.homedir will continue to be supported until version 2.1. The .chezmoi.fullHostname template variable has been removed, as it did not contain the full hostname. Use .chezmoi.fqdnHostname (UNIX only) instead.   "},{"id":2,"href":"/docs/comparison/","title":"Comparison","section":"Docs","content":"Comparison Guide #   Comparison table #      chezmoi dotbot rcm homesick vcsh yadm bare git     Distribution Single binary Python package Multiple files Ruby gem Single script or package Single script -   Install method Many git submodule Many Ruby gem Many Many Manual   Non-root install on bare system ðŸŸ¢ ðŸŸ  ðŸŸ  ðŸŸ  ðŸŸ¢ ðŸŸ¢ ðŸŸ¢   Windows support ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢   Bootstrap requirements None Python, git Perl, git Ruby, git sh, git git git   Source repos Single Single Multiple Single Multiple Single Single   dotfiles are\u0026hellip; Files Symlinks Files Symlinks Files Files Files   Config file Optional Required Optional None None None Optional   Private files ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´   Show differences without applying ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸŸ¢ ðŸŸ¢   Whole file encryption ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´   Password manager integration ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´   Machine-to-machine file differences Templates Alternative files Alternative files Alternative files Branches Templates ðŸŸ    Custom variables in templates ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´   Executable files ðŸŸ¢ ðŸŸ¢ ðŸŸ¢ ðŸŸ¢ ðŸŸ¢ ðŸ”´ ðŸŸ¢   File creation with initial contents ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸ”´   Externals ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´ ðŸ”´   Manage partial files ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ  ðŸ”´ ðŸŸ    File removal ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸ”´   Directory creation ðŸŸ¢ ðŸŸ¢ ðŸŸ¢ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸŸ¢   Run scripts ðŸŸ¢ ðŸŸ¢ ðŸŸ¢ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸ”´   Run once scripts ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸ”´   Machine-to-machine symlink differences ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ  ðŸŸ¢ ðŸŸ    Shell completion ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸŸ¢ ðŸŸ¢   Archive import ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸŸ¢   Archive export ðŸŸ¢ ðŸ”´ ðŸ”´ ðŸ”´ ðŸŸ¢ ðŸ”´ ðŸŸ¢   Implementation language Go Python Perl Ruby POSIX Shell Bash C    ðŸŸ¢ Supported ðŸŸ  Possible with significant manual effort ðŸ”´ Not supported\nFor more comparisons, visit dotfiles.github.io.\n Why should I use a dotfile manager? #  Dotfile managers give you the combined benefit of a consistent environment everywhere with an undo command and a restore from backup.\nAs the core of our development environments become increasingly standardized (e.g. git or Mercurial interfaces to version control at both home and work), and we further customize them (with shell configs like powerlevel10k), at the same time we increasingly work in ephemeral environments like Docker containers and GitHub Codespaces.\nchezmoi helps you bring your personal configuration to every environment that you\u0026rsquo;re working in. In the same way that nobody would use an editor without an undo command, or develop software without a version control system, chezmoi brings the investment that you have made in mastering your tools to every environment that you work in.\n I already have a system to manage my dotfiles, why should I use chezmoi? #   Regular reminder that chezmoi is the best dotfile manager utility I\u0026rsquo;ve used and you can too\nâ€” @mbbroberg\n If you\u0026rsquo;re using any of the following methods:\n A custom shell script. An existing dotfile manager like dotbot, rcm, homesick, vcsh, yadm, or GNU Stow. A bare git repo.  Then you\u0026rsquo;ve probably run into at least one of the following problems.\n Coping with differences between machines requires extra effort #  If you want to synchronize your dotfiles across multiple operating systems or distributions, then you may need to manually perform extra steps to cope with differences from machine to machine. You might need to run different commands on different machines, maintain separate per-machine files or branches (with the associated hassle of merging, rebasing, or copying each change), or hope that your custom logic handles the differences correctly.\nchezmoi uses a single source of truth (a single branch) and a single command that works on every machine. Individual files can be templates to handle machine to machine differences, if needed.\n You have to keep your dotfiles repo private #   And regarding dotfiles, I saw that. It\u0026rsquo;s only public dotfiles repos so I have to evaluate my dotfiles history to be sure. I have secrets scanning and more, but it was easier to keep it private for security, I\u0026rsquo;m ok mostly though. I\u0026rsquo;m using chezmoi and it\u0026rsquo;s easier now\nâ€” @sheldon_hull\n If your system stores secrets in plain text, then you must be very careful about where you clone your dotfiles. If you clone them on your work machine then anyone with access to your work machine (e.g. your IT department) will have access to your home secrets. If you clone it on your home machine then you risk leaking work secrets.\nWith chezmoi you can store secrets in your password manager or encrypt them, and even store passwords in different ways on different machines. You can clone your dotfiles repository anywhere, and even make your dotfiles repo public, without leaving personal secrets on your work machine or work secrets on your personal machine.\n You have to maintain your own tool #   I\u0026rsquo;ve offloaded my dotfiles deployment from a homespun shell script to chezmoi. I\u0026rsquo;m quite happy with this decision.\nâ€” @gotgenes\n  I discovered chezmoi and it\u0026rsquo;s pretty cool, just migrated my old custom multi-machine sync dotfile setup and it\u0026rsquo;s so much simpler now\nin case you\u0026rsquo;re wondering I have written 0 code\nâ€” @buritica\n If your system was written by you for your personal use, then it probably has the functionality that you needed when you wrote it. If you need more functionality then you have to implement it yourself.\nchezmoi includes a huge range of battle-tested functionality out-of-the-box, including dry-run and diff modes, script execution, conflict resolution, Windows support, and much, much more. chezmoi is used by thousands of people and has a rich suite of both unit and integration tests. When you hit the limits of your existing dotfile management system, chezmoi already has a tried-and-tested solution ready for you to use.\n Setting up your dotfiles requires more than one short command #  If your system is written in a scripting language like Python, Perl, or Ruby, then you also need to install a compatible version of that language\u0026rsquo;s runtime before you can use your system.\nchezmoi is distributed as a single stand-alone statically-linked binary with no dependencies that you can simply copy onto your machine and run. You don\u0026rsquo;t even need git installed. chezmoi provides one-line installs, pre-built binaries, packages for Linux and BSD distributions, Homebrew formulae, Scoop and Chocolatey support on Windows, and a initial config file generation mechanism to make installing your dotfiles on a new machine as painless as possible.\n "},{"id":3,"href":"/docs/contributing/","title":"Contributing","section":"Docs","content":"Contributing Guide #   Getting started #  chezmoi is written in Go and development happens on GitHub. The rest of this document assumes that you\u0026rsquo;ve checked out chezmoi locally.\nThe Architecture Guide contains a high-level overview of chezmoi\u0026rsquo;s source code.\n Developing locally #  chezmoi requires Go 1.16 or later.\nchezmoi is a standard Go project, using standard Go tooling.\nBuild chezmoi:\n$ go build Run all tests:\n$ go test ./... chezmoi\u0026rsquo;s tests include integration tests with other software. If the other software is not found in $PATH the tests will be skipped. Running the full set of tests requires age, base64, bash, gpg, perl, python, ruby, sed, sha256sum, unzip, and zip.\nRun chezmoi:\n$ go run . Run a set of smoketests, including cross-compilation, tests, and linting:\n$ make smoketest  Generated code #  chezmoi generates the install script and the website from a single source of truth. You must run\n$ go generate if you change includes any of the following:\n Adds or modifies the list of supported OSs and architectures. Modifies the install script template.  chezmoi\u0026rsquo;s continuous integration verifies that all generated files are up to date. Changes to generated files should be included in the commit that modifies the source of truth.\n Contributing changes #  Bug reports, bug fixes, and documentation improvements are always welcome. Please open an issue or create a pull request with your report, fix, or improvement.\nIf you want to make a more significant change, please first open an issue to discuss the change that you want to make. Dave Cheney gives a good rationale as to why this is important.\nAll changes are made via pull requests. In your pull request, please make sure that:\n  All existing tests pass.\n  There are appropriate additional tests that demonstrate that your PR works as intended.\n  The documentation is updated, if necessary. For new features you should add an entry in docs/HOWTO.md and a complete description in docs/REFERENCE.md.\n  All generated files are up to date. You can ensure this by running make generate and including any modified files in your commit.\n  The code is correctly formatted, according to gofumpt. You can ensure this by running make format.\n  The code passes golangci-lint. You can ensure this by running make lint.\n  The commit messages follow the conventional commits specification.\n  Commits are logically separate, with no merge or \u0026ldquo;fixup\u0026rdquo; commits.\n  The branch applies cleanly to master.\n   Managing releases #  Releases are managed with goreleaser.\nTo build a test release, without publishing, (Linux only) run:\n$ make test-release Publish a new release by creating and pushing a tag, e.g.:\n$ git tag v1.2.3 $ git push --tags This triggers a GitHub Action that builds and publishes archives, packages, and snaps, and creates a new GitHub Release.\nPublishing Snaps requires a SNAPCRAFT_LOGIN repository secret. Snapcraft logins periodically expire. Create a new snapcraft login by running:\n$ snapcraft export-login --snaps=chezmoi --channels=stable,candidate,beta,edge --acls=package_upload - brew automation will automatically detect new releases of chezmoi within a few hours and open a pull request in https://github.com/Homebrew/homebrew-core to bump the version.\nIf needed, the pull request can be created with:\n$ brew bump-formula-pr --tag=v1.2.3 chezmoi  Building and installing with make #  chezmoi can be built with GNU make, assuming you have the Go toolchain installed.\nRunning make will build a chezmoi binary in the current directory for the host OS and architecture. To embed version information in the binary and control installation the following variables are available:\n   Variable Example Purpose     $VERSION v2.0.0 Set version.   $COMMIT 3895680a\u0026hellip; Set the git commit at which the code was built.   $DATE 2019-11-23T18:29:25Z The time of the build.   $BUILT_BY homebrew The packaging system performing the build.   $PREFIX /usr Installation prefix.   $DESTDIR install-root Fake installation root.    Running make install will install the chezmoi binary in ${DESTDIR}${PREFIX}/bin.\n Packaging #  If you\u0026rsquo;re packaging chezmoi for an operating system or distribution:\n  chezmoi has no build dependencies other than the standard Go toolchain.\n  chezmoi has no runtime dependencies, but is usually used with git, so many packagers choose to make git an install dependency or recommended package.\n  Please set the version number, git commit, and build time in the binary. This greatly assists debugging when end users report problems or ask for help. You can do this by passing the following flags to go build:\n-ldflags \u0026quot;-X main.version=$VERSION -X main.commit=$COMMIT -X main.date=$DATE -X main.builtBy=$BUILT_BY\u0026quot; $VERSION should be the chezmoi version, e.g. 1.7.3. Any v prefix is optional and will be stripped, so you can pass the git tag in directly. The command git describe --abbrev=0 --tags will return a suitable value.\n$COMMIT should be the full git commit hash at which chezmoi is built, e.g. 4d678ce6850c9d81c7ab2fe0d8f20c1547688b91. The command git rev-parse HEAD will return a suitable value.\n$DATE should be the date of the build as a UNIX timestamp or in RFC3339 format. The command git show -s --format=%ct HEAD returns the UNIX timestamp of the last commit, e.g. 1636668628. The command date -u +%Y-%m-%dT%H:%M:%SZ returns the current time in RFC3339 format, e.g. 2019-11-23T18:29:25Z.\n$BUILT_BY should be a string indicating what system was used to build the binary. Typically it should be the name of your packaging system, e.g. homebrew.\n  Please enable cgo, if possible. chezmoi can be built and run without cgo, but the .chezmoi.username and .chezmoi.group template variables may not be set correctly on some systems.\n  chezmoi includes an upgrade command which attempts to self-upgrade. You can remove this command completely by building chezmoi with the noupgrade build tag.\n  chezmoi includes shell completions in the completions directory. Please include these in the package and install them in the shell-appropriate directory, if possible.\n  If the instructions for installing chezmoi in chezmoi\u0026rsquo;s install guide are absent or incorrect, please open an issue or submit a PR to correct them.\n   Updating the website #  The website is generated with Hugo and served with GitHub pages from the gh-pages branch to GitHub.\nBefore building the website, you must download the Hugo Book Theme by running:\n$ git submodule update --init Test the website locally by running:\n$ ( cd assets/chezmoi.io \u0026amp;\u0026amp; hugo serve ) and visit http://localhost:1313/.\nTo build the website in a temporary directory, run:\n$ ( cd assets/chezmoi.io \u0026amp;\u0026amp; make ) From here you can run\n$ git show to show changes and\n$ git push to push them. You can only push changes if you have write permissions to the chezmoi GitHub repo.\n "},{"id":4,"href":"/docs/faq/","title":"FAQ","section":"Docs","content":"Frequently Asked Questions #   How can I quickly check for problems with chezmoi on my machine? #  Run:\n$ chezmoi doctor Anything ok is fine, anything warning is only a problem if you want to use the related feature, and anything error indicates a definite problem.\n How do I edit my dotfiles with chezmoi? #  There are four popular approaches:\n Use chezmoi edit $FILE. This will open the source file for $FILE in your editor, including . For extra ease, use chezmoi edit --apply $FILE to apply the changes when you quit your editor. Use chezmoi cd and edit the files in the source directory directly. Run chezmoi diff to see what changes would be made, and chezmoi apply to make the changes. If your editor supports opening directories, run chezmoi edit with no arguments to open the source directory. Edit the file in your home directory, and then either re-add it by running chezmoi add $FILE or chezmoi re-add. Note that re-add doesn\u0026rsquo;t work with templates. Edit the file in your home directory, and then merge your changes with source state by running chezmoi merge $FILE.   Do I have to use chezmoi edit to edit my dotfiles? #  No. chezmoi edit is a convenience command that has a couple of useful features, but you don\u0026rsquo;t have to use it. You can also run chezmoi cd and then just edit the files in the source state directly. After saving an edited file you can run chezmoi diff to check what effect the changes would have, and run chezmoi apply if you\u0026rsquo;re happy with them.\nchezmoi edit provides the following useful features:\n It opens the correct file in the source state for you with a filename matching the target filename, so your editor\u0026rsquo;s syntax highlighting will work and you don\u0026rsquo;t have to know anything about source state attributes. If the dotfile is encrypted in the source state, then chezmoi edit will decrypt it to a private directory, open that file in your $EDITOR, and then re-encrypt the file when you quit your editor. That makes encryption more transparent to the user. With the --diff and --apply options you can see what would change and apply those changes without having to run chezmoi diff or chezmoi apply. Note also that the arguments to chezmoi edit are the files in their target location.   What are the consequences of \u0026ldquo;bare\u0026rdquo; modifications to the target files? If my .zshrc is managed by chezmoi and I edit ~/.zshrc without using chezmoi edit, what happens? #  Until you run chezmoi apply your modified ~/.zshrc will remain in place. When you run chezmoi apply chezmoi will detect that ~/.zshrc has changed since chezmoi last wrote it and prompt you what to do. You can resolve differences with a merge tool by running chezmoi merge ~/.zshrc.\n How can I tell what dotfiles in my home directory aren\u0026rsquo;t managed by chezmoi? Is there an easy way to have chezmoi manage a subset of them? #  chezmoi unmanaged will list everything not managed by chezmoi. You can add entire directories with chezmoi add.\n How can I tell what dotfiles in my home directory are currently managed by chezmoi? #  chezmoi managed will list everything managed by chezmoi.\n If there\u0026rsquo;s a mechanism in place for the above, is there also a way to tell chezmoi to ignore specific files or groups of files (e.g. by directory name or by glob)? #  By default, chezmoi ignores everything that you haven\u0026rsquo;t explicitly added. If you have files in your source directory that you don\u0026rsquo;t want added to your destination directory when you run chezmoi apply add their names to a file called .chezmoiignore in the source state.\nPatterns are supported, and you can change what\u0026rsquo;s ignored from machine to machine. The full usage and syntax is described in the reference manual.\n If the target already exists, but is \u0026ldquo;behind\u0026rdquo; the source, can chezmoi be configured to preserve the target version before replacing it with one derived from the source? #  Yes. Run chezmoi add will update the source state with the target. To see diffs of what would change, without actually changing anything, use chezmoi diff.\n Once I\u0026rsquo;ve made a change to the source directory, how do I commit it? #  You have several options:\n chezmoi cd opens a shell in the source directory, where you can run your usual version control commands, like git add and git commit. chezmoi git runs git in the source directory and pass extra arguments to the command. If you\u0026rsquo;re passing any flags, you\u0026rsquo;ll need to use -- to prevent chezmoi from consuming them, for example chezmoi git -- commit -m \u0026quot;Update dotfiles\u0026quot;. You can configure chezmoi to automatically commit and push changes to your source state, as described in the how-to guide.   I\u0026rsquo;ve made changes to both the destination state and the source state that I want to keep. How can I keep them both? #  chezmoi merge will open a merge tool to resolve differences between the source state, target state, and destination state. Copy the changes you want to keep in to the source state.\n Why does chezmoi convert all my template variables to lowercase? #  This is due to a feature in github.com/spf13/viper, the library that chezmoi uses to read its configuration file. For more information see this GitHub issue.\n chezmoi makes ~/.ssh/config group writeable. How do I stop this? #  By default, chezmoi uses your system\u0026rsquo;s umask when creating files. On most systems the default umask is 022 but some systems use 002, which means that files and directories are group writeable by default.\nYou can override this for chezmoi by setting the umask configuration variable in your configuration file, for example:\numask = 0o022 Note that this will apply to all files and directories that chezmoi manages and will ensure that none of them are group writeable. It is not currently possible to control group write permissions for individual files or directories. Please open an issue on GitHub if you need this.\n Why does chezmoi cd spawn a shell instead of just changing directory? #  chezmoi cd spawns a shell because it is not possible for a program to change the working directory of its parent process. You can add a shell function instead:\nchezmoi-cd() { cd $(chezmoi source-path) } Typing chezmoi-cd will then change the directory of your current shell to chezmoi\u0026rsquo;s source directory.\n Why doesn\u0026rsquo;t chezmoi use symlinks like GNU Stow? #  Symlinks are first class citizens in chezmoi: chezmoi supports creating them, updating them, removing them, and even more advanced features not found elsewhere like having the same symlink point to different targets on different machines by using a template.\nWith chezmoi, you only use a symlink where you really need a symlink, in contrast to some other dotfile managers (e.g. GNU Stow) which require the use of symlinks as a layer of indirection between a dotfile\u0026rsquo;s location (which can be anywhere in your home directory) and a dotfile\u0026rsquo;s content (which needs to be in a centralized directory that you manage with version control). chezmoi solves this problem in a different way.\nInstead of using a symlink to redirect from the dotfile\u0026rsquo;s location to the centralized directory, chezmoi generates the dotfile as a regular file in its final location from the contents of the centralized directory. This approach allows chezmoi to provide features that are not possible when using symlinks, for example having files that are encrypted, executable, private, or templates.\nThere\u0026rsquo;s nothing special about dotfiles managed by chezmoi, whereas dotfiles managed with GNU Stow are special because they\u0026rsquo;re actually symlinks to somewhere else.\nThe only advantage to using GNU Stow-style symlinks is that changes that you make to the dotfile\u0026rsquo;s contents in the centralized directory are immediately visible, whereas chezmoi currently requires you to run chezmoi apply or chezmoi edit --apply. chezmoi will likely get an alternative solution to this too, see #752.\nIf you really want to use symlinks, then chezmoi provides a symlink mode which uses symlinks where possible.\nYou can configure chezmoi to work like GNU Stow and have it create a set of symlinks back to a central directory, but this currently requires a bit of manual work (as described in #167). chezmoi might get some automation to help (see #886 for example) but it does need some convincing use cases that demonstrate that a symlink from a dotfile\u0026rsquo;s location to its contents in a central directory is better than just having the correct dotfile contents.\n What are the limitations of chezmoi\u0026rsquo;s symlink mode? #  In symlink mode chezmoi replaces targets with symlinks to the source directory if the the target is a regular file and is not encrypted, executable, private, or a template.\nSymlinks cannot be used for encrypted files because the source state contains the ciphertext, not the plaintext.\nSymlinks cannot be used for executable files as the executable bit would need to be set on the file in the source directory and chezmoi uses only regular files and directories in its source state for portability across operating systems. This may change in the future.\nSymlinks cannot be used for private files because git does not persist group and world permission bits.\nSymlinks cannot be used for templated files because the source state contains the template, not the result of executing the template.\nSymlinks cannot be used for entire directories because of chezmoi\u0026rsquo;s use of attributes in the filename mangles entries in the directory, directories might have the exact_ attribute and contain empty files, and the directory\u0026rsquo;s entries might not be usable with symlinks.\nIn symlink mode, running chezmoi add does not immediately replace the targets with a symlink. You must run chezmoi apply to create the symlinks.\n Can I change how chezmoi\u0026rsquo;s source state is represented on disk? #  There are a number of criticisms of how chezmoi\u0026rsquo;s source state is represented on disk:\n Not all possible file permissions can be represented. The long source file names are weird and verbose. Everything is in a single directory, which can end up containing many entries.  chezmoi\u0026rsquo;s source state representation is a deliberate, practical compromise.\nThe dot_ attribute makes it transparent which dotfiles are managed by chezmoi and which files are ignored by chezmoi. chezmoi ignores all files and directories that start with . so no special whitelists are needed for version control systems and their control files (e.g. .git and .gitignore).\nchezmoi needs per-file metadata to know how to interpret the source file\u0026rsquo;s contents, for example to know when the source file is a template or if the file\u0026rsquo;s contents are encrypted. By storing this metadata in the filename, the metadata is unambiguously associated with a single file and adding, updating, or removing a single file touches only a single file in the source state. Changes to the metadata (e.g. chezmoi chattr +template *target*) are simple file renames and isolated to the affected file.\nIf chezmoi were to, say, use a common configuration file listing which files were templates and/or encrypted, then changes to any file would require updates to the common configuration file. Automating updates to configuration files requires a round trip (read config file, update config, write config) and it is not always possible preserve comments and formatting.\nchezmoi\u0026rsquo;s attributes of executable_, private_, and readonly_ allow a the file permissions 0o644, 0o755, 0o600, 0o700, 0o444, 0o555, 0o400, and 0o500 to be represented. Directories can only have permissions 0o755, 0o700, or 0o500. In practice, these cover all permissions typically used for dotfiles. If this does cause a genuine problem for you, please open an issue on GitHub.\nFile permissions and modes like executable_, private_, readonly_, and symlink_ could also be stored in the filesystem, rather than in the filename. However, this requires the permissions to be preserved and handled by the underlying version control system and filesystem. chezmoi provides first-class support for Windows, where the executable_ and private_ attributes have no direct equivalents and symbolic links are not always permitted. By using regular files and directories, chezmoi avoids variations in the operating system, version control system, and filesystem making it both more robust and more portable.\nchezmoi uses a 1:1 mapping between entries in the source state and entries in the target state. This mapping is bi-directional and unambiguous.\nHowever, this also means that dotfiles that in the same directory in the target state must be in the same directory in the source state. In particular, every entry managed by chezmoi in the root of your home directory has a corresponding entry in the root of your source directory, which can mean that you end up with a lot of entries in the root of your source directory.\nIf chezmoi were to permit, say, multiple separate source directories (so you could, say, put dot_bashrc in a bash/ subdirectory, and dot_vimrc in a vim/ subdirectory, but have chezmoi apply map these to ~/.bashrc and ~/.vimrc in the root of your home directory) then the mapping between source and target states is no longer bidirectional nor unambiguous, which significantly increases complexity and requires more user interaction. For example, if both bash/dot_bashrc and vim/dot_bashrc exist, what should be the contents of ~/.bashrc? If you run chezmoi add ~/.zshrc, should dot_zshrc be stored in the source bash/ directory, the source vim/ directory, or somewhere else? How does the user communicate their preferences?\nchezmoi has many users and any changes to the source state representation must be backwards-compatible.\nIn summary, chezmoi\u0026rsquo;s source state representation is a compromise with both advantages and disadvantages. Changes to the representation will be considered, but must meet the following criteria, in order of importance:\n Be fully backwards-compatible for existing users. Fix a genuine problem encountered in practice. Be independent of the underlying operating system, version control system, and filesystem. Not add significant extra complexity to the user interface or underlying implementation.   The output of chezmoi diff is broken and does not contain color. What could be wrong? #  By default, chezmoi\u0026rsquo;s diff output includes ANSI color escape sequences (e.g. ESC[37m) and is piped into your pager (by default less). chezmoi assumes that your pager passes through the ANSI color escape sequences, as configured on many systems, but not all. If your pager does not pass through ANSI color escape sequences then you will see monochrome diff output with uninterpreted ANSI color escape sequences.\nThis can typically by fixed by setting the environment variable\n$ export LESS=-R which instructs less to display \u0026ldquo;raw\u0026rdquo; control characters via the -R / --RAW-CONTROL-CHARS option.\nYou can also set the pager configuration variable in your config file, for example:\npager = \u0026#34;less -R\u0026#34; If you have set a different pager (via the pager configuration variable or PAGER environment variable) then you must ensure that it passes through raw control characters. Alternatively, you can use the --color=false option to chezmoi to disable colors or the --no-pager option to chezmoi to disable the pager.\n gpg encryption fails. What could be wrong? #  The gpg.recipient key should be ultimately trusted, otherwise encryption will fail because gpg will prompt for input, which chezmoi does not handle. You can check the trust level by running:\n$ gpg --export-ownertrust The trust level for the recipient\u0026rsquo;s key should be 6. If it is not, you can change the trust level by running:\n$ gpg --edit-key $recipient Enter trust at the prompt and chose 5 = I trust ultimately.\n chezmoi reports chezmoi: user: lookup userid NNNNN: input/output error #  This is likely because the chezmoi binary you are using was statically compiled with musl and the machine you are running on uses LDAP or NIS.\nThe immediate fix is to use a package built for your distribution (e.g a .deb or .rpm) which is linked against glibc and includes LDAP/NIS support instead of the statically-compiled binary.\nIf the problem still persists, then please open an issue on GitHub.\n chezmoi reports chezmoi: timeout or chezmoi: timeout obtaining persistent state lock #  chezmoi will report this when it is unable to lock its persistent state (~/.config/chezmoi/chezmoistate.boltdb), typically because another instance of chezmoi is currently running and holding the lock.\nThis can happen, for example, if you have a run_ script that invokes chezmoi, or are running chezmoi in another window.\nUnder the hood, chezmoi uses bbolt which permits multiple simultaneous readers, but only one writer (with no readers).\nCommands that take a write lock include add, apply, edit, forget, import, init, state, unmanage, and update. Commands that take a read lock include diff, status, and verify.\n I\u0026rsquo;m getting errors trying to build chezmoi from source #  chezmoi requires Go version 1.16 or later. You can check the version of Go with:\n$ go version If you try to build chezmoi with an earlier version of Go you will get the error:\npackage github.com/twpayne/chezmoi/v2: build constraints exclude all Go files in /home/twp/src/github.com/twpayne/chezmoi This is because chezmoi includes the build tag go1.16 in main.go, which is only set on Go 1.16 or later.\nFor more details on building chezmoi, see the Contributing Guide.\n What inspired chezmoi? #  chezmoi was inspired by Puppet, but was created because Puppet is an overkill for managing your personal configuration files. The focus of chezmoi will always be personal home directory management. If your needs grow beyond that, switch to a whole system configuration management tool.\n Why not use Ansible/Chef/Puppet/Salt, or similar to manage my dotfiles instead? #  Whole system management tools are more than capable of managing your dotfiles, but are large systems that entail several disadvantages. Compared to whole system management tools, chezmoi offers:\n Small, focused feature set designed for dotfiles. There\u0026rsquo;s simply less to learn with chezmoi compared to whole system management tools. Easy installation and execution on every platform, without root access. Installing chezmoi requires only copying a single binary file with no external dependencies. Executing chezmoi just involves running the binary. In contrast, installing and running a whole system management tool typically requires installing a scripting language runtime, several packages, and running a system service, all typically requiring root access.  chezmoi\u0026rsquo;s focus and simple installation means that it runs almost everywhere: from tiny ARM-based Linux systems to Windows desktops, from inside lightweight containers to FreeBSD-based virtual machines in the cloud.\n Can I use chezmoi to manage files outside my home directory? #  In practice, yes, you can, but this is strongly discouraged beyond using your system\u0026rsquo;s package manager to install the packages you need.\nchezmoi is designed to operate on your home directory, and is explicitly not a full system configuration management tool. That said, there are some ways to have chezmoi manage a few files outside your home directory.\nchezmoi\u0026rsquo;s scripts can execute arbitrary commands, so you can use a run_ script that is run every time you run chezmoi apply, to, for example:\n Make the target file outside your home directory a symlink to a file managed by chezmoi in your home directory. Copy a file managed by chezmoi inside your home directory to the target file. Execute a template with chezmoi execute-template --output=filename template where filename is outside the target directory.  chezmoi executes all scripts as the user executing chezmoi, so you may need to add extra privilege elevation commands like sudo or PowerShell start -verb runas -wait to your script.\nchezmoi, by default, operates on your home directory but this can be overridden with the --destination command line flag or by specifying destDir in your config file, and could even be the root directory (/ or C:\\). This allows you, in theory, to use chezmoi to manage any file in your filesystem, but this usage is extremely strongly discouraged.\nIf your needs extend beyond modifying a handful of files outside your target system, then existing configuration management tools like Puppet, Chef, Ansible, and Salt are much better suited - and of course can be called from a chezmoi run_ script. Put your Puppet Manifests, Chef Recipes, Ansible Modules, and Salt Modules in a directory ignored by .chezmoiignore so they do not pollute your home directory.\n Where does the name \u0026ldquo;chezmoi\u0026rdquo; come from? #  \u0026ldquo;chezmoi\u0026rdquo; splits to \u0026ldquo;chez moi\u0026rdquo; and pronounced /ÊƒeÉª mwa/ (shay-moi) meaning \u0026ldquo;at my house\u0026rdquo; in French. It\u0026rsquo;s seven letters long, which is an appropriate length for a command that is only run occasionally.\n What other questions have been asked about chezmoi? #  See the issues on GitHub.\n Where do I ask a question that isn\u0026rsquo;t answered here? #  Please open an issue on GitHub.\n I like chezmoi. How do I say thanks? #  Thank you! chezmoi was written to scratch a personal itch, and I\u0026rsquo;m very happy that it\u0026rsquo;s useful to you. Please give chezmoi a star on GitHub, and if you\u0026rsquo;re happy to share your public dotfile repo then tag it with chezmoi.\nIf you write an article or give a talk on chezmoi please inform the author (e.g. by opening an issue) so it can be added to chezmoi\u0026rsquo;s media page.\nContributions are very welcome and every bug report, support request, and feature request helps make chezmoi better. Thank you :)\n "},{"id":5,"href":"/docs/how-to/","title":"How-To","section":"Docs","content":"How-To Guide #   Perform daily operations #   Use a hosted repo to manage your dotfiles across multiple machines #  chezmoi relies on your version control system and hosted repo to share changes across multiple machines. You should create a repo on the source code repository of your choice (e.g. Bitbucket, GitHub, or GitLab, many people call their repo dotfiles) and push the repo in the source directory here. For example:\n$ chezmoi cd $ git remote add origin https://github.com/username/dotfiles.git $ git push -u origin main $ exit On another machine you can checkout this repo:\n$ chezmoi init https://github.com/username/dotfiles.git You can then see what would be changed:\n$ chezmoi diff If you\u0026rsquo;re happy with the changes then apply them:\n$ chezmoi apply The above commands can be combined into a single init, checkout, and apply:\n$ chezmoi init --apply --verbose https://github.com/username/dotfiles.git  Use a private repo to store your dotfiles #  chezmoi supports storing your dotfiles in both public and private repos.\nchezmoi is designed so that your dotfiles repo can be public by making it easy for you to store your secrets either in your password manager, in encrypted files, or in private configuration files. Your dotfiles repo can still be private, if you choose.\nIf you use a private repo for your dotfiles then you will typically need to enter your credentials (e.g. your username and password) each time you interact with the repo, for example when pulling or pushing changes. chezmoi itself does not store any credentials, but instead relies on your local git configuration for these operations.\nWhen using a private repo on GitHub, when prompted for a password you will need to enter a GitHub personal access token. For more information on these changes, read the GitHub blog post on Token authentication requirements for Git operations\n Pull the latest changes from your repo and apply them #  You can pull the changes from your repo and apply them in a single command:\n$ chezmoi update This runs git pull --rebase in your source directory and then chezmoi apply.\n Pull the latest changes from your repo and see what would change, without actually applying the changes #  Run:\n$ chezmoi git pull -- --rebase \u0026amp;\u0026amp; chezmoi diff This runs git pull --rebase in your source directory and chezmoi diff then shows the difference between the target state computed from your source directory and the actual state.\nIf you\u0026rsquo;re happy with the changes, then you can run\n$ chezmoi apply to apply them.\n Automatically commit and push changes to your repo #  chezmoi can automatically commit and push changes to your source directory to your repo. This feature is disabled by default. To enable it, add the following to your config file:\n[git] autoCommit = true autoPush = true Whenever a change is made to your source directory, chezmoi will commit the changes with an automatically-generated commit message (if autoCommit is true) and push them to your repo (if autoPush is true). autoPush implies autoCommit, i.e. if autoPush is true then chezmoi will auto-commit your changes. If you only set autoCommit to true then changes will be committed but not pushed.\nBe careful when using autoPush. If your dotfiles repo is public and you accidentally add a secret in plain text, that secret will be pushed to your public repo.\n Install chezmoi and your dotfiles on a new machine with a single command #  chezmoi\u0026rsquo;s install script can run chezmoi init for you by passing extra arguments to the newly installed chezmoi binary. If your dotfiles repo is github.com/\u0026lt;github-username\u0026gt;/dotfiles then installing chezmoi, running chezmoi init, and running chezmoi apply can be done in a single line of shell:\n$ sh -c \u0026#34;$(curl -fsLS git.io/chezmoi)\u0026#34; -- init --apply \u0026lt;github-username\u0026gt; If your dotfiles repo has a different name to dotfiles, or if you host your dotfiles on a different service, then see the reference manual for chezmoi init.\nFor setting up transitory environments (e.g. short-lived Linux containers) you can install chezmoi, install your dotfiles, and then remove all traces of chezmoi, including the source directory and chezmoi\u0026rsquo;s configuration directory, with a single command:\n$ sh -c \u0026#34;$(curl -fsLS git.io/chezmoi)\u0026#34; -- init --one-shot \u0026lt;github-username\u0026gt;  Manage different types of file #   Have chezmoi create a directory, but ignore its contents #  If you want chezmoi to create a directory, but ignore its contents, say ~/src, first run:\n$ mkdir -p $(chezmoi source-path)/src This creates the directory in the source state, which means that chezmoi will create it (if it does not already exist) when you run chezmoi apply.\nHowever, as this is an empty directory it will be ignored by git. So, create a file in the directory in the source state that will be seen by git (so git does not ignore the directory) but ignored by chezmoi (so chezmoi does not include it in the target state):\n$ touch $(chezmoi source-path)/src/.keep chezmoi automatically creates .keep files when you add an empty directory with chezmoi add.\n Ensure that a target is removed #  Create a file called .chezmoiremove in the source directory containing a list of patterns of files to remove. chezmoi will remove anything in the target directory that matches the pattern. As this command is potentially dangerous, you should run chezmoi in verbose, dry-run mode beforehand to see what would be removed:\n$ chezmoi apply --dry-run --verbose .chezmoiremove is interpreted as a template, so you can remove different files on different machines. Negative matches (patterns prefixed with a !) or targets listed in .chezmoiignore will never be removed.\n Manage part, but not all, of a file #  chezmoi, by default, manages whole files, but there are two ways to manage just parts of a file.\nFirstly, a modify_ script receives the current contents of the file on the standard input and chezmoi reads the target contents of the file from the script\u0026rsquo;s standard output. This can be used to change parts of a file, for example using sed. Note that if the file does not exist then the standard input to the modify_ script will be empty and it is the script\u0026rsquo;s responsibility to write a complete file to the standard output.\nSecondly, if only a small part of the file changes then consider using a template to re-generate the full contents of the file from the current state. For example, Kubernetes configurations include a current context that can be substituted with:\ncurrent-context: {{ output \u0026quot;kubectl\u0026quot; \u0026quot;config\u0026quot; \u0026quot;current-context\u0026quot; | trim }}  Manage a file\u0026rsquo;s permissions, but not its contents #  chezmoi\u0026rsquo;s create_ attributes allows you to tell chezmoi to create a file if it does not already exist. chezmoi, however, will apply any permission changes from the executable_, private_, and readonly_ attributes. This can be used to control a file\u0026rsquo;s permissions without altering its contents.\nFor example, if you want to ensure that ~/.kube/config always has permissions 600 then if you create an empty file called dot_kube/private_dot_config in your source state, chezmoi will ensure ~/.kube/config\u0026rsquo;s permissions are 0600 when you run chezmoi apply without changing its contents.\nThis approach does have the downside that chezmoi will create the file if it does not already exist. If you only want chezmoi apply to set a file\u0026rsquo;s permissions if it already exists and not create the file otherwise, you can use a run_ script. For example, create a file in your source state called run_set_kube_config_permissions.sh containing:\n#!/bin/sh  FILE=\u0026#34;$HOME/.kube/config\u0026#34; if [ -f \u0026#34;$FILE\u0026#34; ]; then if [ \u0026#34;$(stat -c %a \u0026#34;$FILE\u0026#34;)\u0026#34; != \u0026#34;600\u0026#34; ] ; then chmod 600 \u0026#34;$FILE\u0026#34; fi fi  Populate ~/.ssh/authorized_keys with your public SSH keys from GitHub #  chezmoi can retrieve your public SSH keys from GitHub, which can be useful for populating your ~/.ssh/authorized_keys. Put the following in your ~/.local/share/chezmoi/dot_ssh/authorized_keys.tmpl, where username is your GitHub username:\n{{ range (gitHubKeys \u0026quot;username\u0026quot;) -}} {{ .Key }} {{ end -}}  Integrate chezmoi with your editor #   Use your preferred editor with chezmoi edit and chezmoi edit-config #  By default, chezmoi will use your preferred editor as defined by the $VISUAL or $EDITOR environment variables, falling back to a default editor depending on your operating system (vi on UNIX-like operating systems, notepad.exe on Windows).\nYou can configure chezmoi to use your preferred editor by either setting the $EDITOR environment variable or setting the edit.command variable in your configuration file.\nThe editor command must only return when you have finished editing the files. chezmoi will emit a warning if your editor command returns too quickly.\nIn the specific case of using VSCode or Codium as your editor, you must pass the --wait flag, for example, in your shell config:\n$ export EDITOR=\u0026#34;code --wait\u0026#34; Or in chezmoi\u0026rsquo;s configuration file:\n[edit] command = \u0026#34;code\u0026#34; args = [\u0026#34;--wait\u0026#34;]  Configure VIM to run chezmoi apply whenever you save a dotfile #  Put the following in your .vimrc:\nautocmd BufWritePost ~/.local/share/chezmoi/* ! chezmoi apply --source-path \u0026#34;%\u0026#34; Include dotfiles from elsewhere #   Include a subdirectory from another repository, like Oh My Zsh #  To include a subdirectory from another repository, e.g. Oh My Zsh, you cannot use git submodules because chezmoi uses its own format for the source state and Oh My Zsh is not distributed in this format. Instead, you can use the .chezmoiexternal.\u0026lt;format\u0026gt; to tell chezmoi to import dotfiles from an external source.\nFor example, to import Oh My Zsh, the zsh-syntax-highlighting plugin, and powerlevel10k, put the following in ~/.local/share/chezmoi/.chezmoiexternal.toml:\n[\u0026#34;.oh-my-zsh\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/ohmyzsh/ohmyzsh/archive/master.tar.gz\u0026#34; exact = true stripComponents = 1 refreshPeriod = \u0026#34;168h\u0026#34; [\u0026#34;.oh-my-zsh/custom/plugins/zsh-syntax-highlighting\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/zsh-users/zsh-syntax-highlighting/archive/master.tar.gz\u0026#34; exact = true stripComponents = 1 refreshPeriod = \u0026#34;168h\u0026#34; [\u0026#34;.oh-my-zsh/custom/themes/powerlevel10k\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/romkatv/powerlevel10k/archive/v1.15.0.tar.gz\u0026#34; exact = true stripComponents = 1 To apply the changes, run:\n$ chezmoi apply chezmoi will download the archives and unpack them as if they were part of the source state. chezmoi caches downloaded archives locally to avoid re-downloading them every time you run a chezmoi command, and will only re-download them at most every refreshPeriod (default never).\nIn the above example refreshPeriod is set to 168h (one week) for .oh-my-zsh and .oh-my-zsh/custom/plugins/zsh-syntax-highlighting because the URL point to tarballs of the master branch, which changes over time. No refresh period is set for .oh-my-zsh/custom/themes/powerlevel10k because the URL points to the a tarball of a tagged version, which does not change over time. To bump the version of powerlevel10k, change the version in the URL.\nTo force a refresh the downloaded archives, use the --refresh-externals flag to chezmoi apply:\n$ chezmoi --refresh-externals apply --refresh-externals can be shortened to -R:\n$ chezmoi -R apply When using Oh My Zsh, make sure you disable auto-updates by setting DISABLE_AUTO_UPDATE=\u0026quot;true\u0026quot; in ~/.zshrc. Auto updates will cause the ~/.oh-my-zsh directory to drift out of sync with chezmoi\u0026rsquo;s source state. To update Oh My Zsh and its plugins, refresh the downloaded archives.\n Include a single file from another repository #  Including single files uses the same mechanism as including a subdirectory above, except with the external type file instead of archive. For example, to include plug.vim from github.com/junegunn/vim-plug in ~/.vim/autoload/plug.vim put the following in ~/.local/share/chezmoi/.chezmoiexternals.toml:\n[\u0026#34;.vim/autoload/plug.vim\u0026#34;] type = \u0026#34;file\u0026#34; url = \u0026#34;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#34; refreshPeriod = \u0026#34;168h\u0026#34;  Handle configuration files which are externally modified #  Some programs modify their configuration files. When you next run chezmoi apply, any modifications made by the program will be lost.\nYou can track changes to these files by replacing with a symlink back to a file in your source directory, which is under version control. Here is a worked example for VSCode\u0026rsquo;s settings.json on Linux:\nCopy the configuration file to your source directory:\n$ cp ~/.config/Code/User/settings.json $(chezmoi source-path) Tell chezmoi to ignore this file:\n$ echo settings.json \u0026gt;\u0026gt; $(chezmoi source-path)/.chezmoiignore Tell chezmoi that ~/.config/Code/User/settings.json should be a symlink to the file in your source directory:\n$ mkdir -p $(chezmoi source-path)/private_dot_config/private_Code/User $ echo -n \u0026#34;{{ .chezmoi.sourceDir }}/settings.json\u0026#34; \u0026gt; $(chezmoi source-path)/private_dot_config/private_Code/User/symlink_settings.json.tmpl The prefix private_ is used because the ~/.config and ~/.config/Code directories are private by default.\nApply the changes:\n$ chezmoi apply -v Now, when the program modifies its configuration file it will modify the file in the source state instead.\n Import archives #  It is occasionally useful to import entire archives of configuration into your source state. The import command does this. For example, to import the latest version github.com/ohmyzsh/ohmyzsh to ~/.oh-my-zsh run:\n$ curl -s -L -o ${TMPDIR}/oh-my-zsh-master.tar.gz https://github.com/ohmyzsh/ohmyzsh/archive/master.tar.gz $ mkdir -p $(chezmoi source-path)/dot_oh-my-zsh $ chezmoi import --strip-components 1 --destination ~/.oh-my-zsh ${TMPDIR}/oh-my-zsh-master.tar.gz Note that this only updates the source state. You will need to run\n$ chezmoi apply to update your destination directory.\n Manage machine-to-machine differences #   Use templates #  The primary goal of chezmoi is to manage configuration files across multiple machines, for example your personal macOS laptop, your work Ubuntu desktop, and your work Linux laptop. You will want to keep much configuration the same across these, but also need machine-specific configurations for email addresses, credentials, etc. chezmoi achieves this functionality by using text/template for the source state where needed.\nFor example, your home ~/.gitconfig on your personal machine might look like:\n[user] email = \u0026#34;me@home.org\u0026#34; Whereas at work it might be:\n[user] email = \u0026#34;firstname.lastname@company.com\u0026#34; To handle this, on each machine create a configuration file called ~/.config/chezmoi/chezmoi.toml defining variables that might vary from machine to machine. For example, for your home machine:\n[data] email = \u0026#34;me@home.org\u0026#34; Note that all variable names will be converted to lowercase. This is due to a feature of a library used by chezmoi.\nIf you intend to store private data (e.g. access tokens) in ~/.config/chezmoi/chezmoi.toml, make sure it has permissions 0600.\nIf you prefer, you can use any format supported by Viper for your configuration file. This includes JSON, YAML, and TOML. Variable names must start with a letter and be followed by zero or more letters or digits.\nThen, add ~/.gitconfig to chezmoi using the --autotemplate flag to turn it into a template and automatically detect variables from the data section of your ~/.config/chezmoi/chezmoi.toml file:\n$ chezmoi add --autotemplate ~/.gitconfig You can then open the template (which will be saved in the file ~/.local/share/chezmoi/dot_gitconfig.tmpl):\n$ chezmoi edit ~/.gitconfig The file should look something like:\n[user] email = {{ .email | quote }} To disable automatic variable detection, use the --template or -T option to chezmoi add instead of --autotemplate.\nTemplates are often used to capture machine-specific differences. For example, in your ~/.local/share/chezmoi/dot_bashrc.tmpl you might have:\n# common config export EDITOR=vi # machine-specific configuration {{- if eq .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} # this will only be included in ~/.bashrc on work-laptop {{- end }} For a full list of variables, run:\n$ chezmoi data For more advanced usage, you can use the full power of the text/template language. chezmoi includes all of the text functions from sprig and its own functions for interacting with password managers.\nTemplates can be executed directly from the command line, without the need to create a file on disk, with the execute-template command, for example:\n$ chezmoi execute-template \u0026#34;{{ .chezmoi.os }}/{{ .chezmoi.arch }}\u0026#34; This is useful when developing or debugging templates.\nSome password managers allow you to store complete files. The files can be retrieved with chezmoi\u0026rsquo;s template functions. For example, if you have a file stored in 1Password with the UUID uuid then you can retrieve it with the template:\n{{- onepasswordDocument \u0026quot;uuid\u0026quot; -}} The -s inside the brackets remove any whitespace before or after the template expression, which is useful if your editor has added any newlines.\nIf, after executing the template, the file contents are empty, the target file will be removed. This can be used to ensure that files are only present on certain machines. If you want an empty file to be created anyway, you will need to give it an empty_ prefix.\n Ignore files or a directory on different machines #  For coarser-grained control of files and entire directories managed on different machines, or to exclude certain files completely, you can create .chezmoiignore files in the source directory. These specify a list of patterns that chezmoi should ignore, and are interpreted as templates. An example .chezmoiignore file might look like:\nREADME.md {{- if ne .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} .work # only manage .work on work-laptop {{- end }} The use of ne (not equal) is deliberate. What we want to achieve is \u0026ldquo;only install .work if hostname is work-laptop\u0026rdquo; but chezmoi installs everything by default, so we have to turn the logic around and instead write \u0026ldquo;ignore .work unless the hostname is work-laptop\u0026rdquo;.\nPatterns can be excluded by prefixing them with a !, for example:\nf* !foo will ignore all files beginning with an f except foo.\n Use completely different dotfiles on different machines #  chezmoi\u0026rsquo;s template functionality allows you to change a file\u0026rsquo;s contents based on any variable. For example, if you want ~/.bashrc to be different on Linux and macOS you would create a file in the source state called dot_bashrc.tmpl containing:\n{{ if eq .chezmoi.os \u0026quot;darwin\u0026quot; -}} # macOS .bashrc contents {{ else if eq .chezmoi.os \u0026quot;linux\u0026quot; -}} # Linux .bashrc contents {{ end -}} However, if the differences between the two versions are so large that you\u0026rsquo;d prefer to use completely separate files in the source state, you can achieve this using a symbolic link template. Create the following files:\nsymlink_dot_bashrc.tmpl:\n.bashrc_{{ .chezmoi.os }} dot_bashrc_darwin:\n # macOS .bashrc contents dot_bashrc_linux:\n# Linux .bashrc contents .chezmoiignore\n{{ if ne .chezmoi.os \u0026quot;darwin\u0026quot; }} .bashrc_darwin {{ end }} {{ if ne .chezmoi.os \u0026quot;linux\u0026quot; }} .bashrc_linux {{ end }} This will make ~/.bashrc a symlink to .bashrc_darwin on darwin and to .bashrc_linux on linux. The .chezmoiignore configuration ensures that only the OS-specific .bashrc_os file will be installed on each OS.\nWithout using symlinks #  The same thing can be achieved using the include function.\ndot_bashrc.tmpl\n{{ if eq .chezmoi.os \u0026quot;darwin\u0026quot; }} {{ include \u0026quot;.bashrc_darwin\u0026quot; }} {{ end }} {{ if eq .chezmoi.os \u0026quot;linux\u0026quot; }} {{ include \u0026quot;.bashrc_linux\u0026quot; }} {{ end }}  Create a config file on a new machine automatically #  chezmoi init can also create a config file automatically, if one does not already exist. If your repo contains a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl where format is one of the supported config file formats (e.g. json, toml, or yaml) then chezmoi init will execute that template to generate your initial config file.\nSpecifically, if you have .chezmoi.toml.tmpl that looks like this:\n{{- $email := promptString \u0026quot;email\u0026quot; -}} [data] email = {{ $email | quote }} Then chezmoi init will create an initial chezmoi.toml using this template. promptString is a special function that prompts the user (you) for a value.\nTo test this template, use chezmoi execute-template with the --init and --promptString flags, for example:\n$ chezmoi execute-template --init --promptString email=me@home.org \u0026lt; ~/.local/share/chezmoi/.chezmoi.toml.tmpl  Re-create your config file #  If you change your config file template, chezmoi will warn you if your current config file was not generated from that template. You can re-generate your config file by running:\n$ chezmoi init If you are using any prompt* template functions in your config file template you will be prompted again. However, you can avoid this with the following example template logic:\n{{- $email := \u0026quot;\u0026quot; -}} {{- if (hasKey . \u0026quot;email\u0026quot;) -}} {{- $email = .email -}} {{- else -}} {{- $email = promptString \u0026quot;email\u0026quot; -}} {{- end -}} [data] email = {{ $email | quote }} This will cause chezmoi to first try to re-use the existing $email variable and fallback to promptString only if it is not set.\n Handle different file locations on different systems with the same contents #  If you want to have the same file contents in different locations on different systems, but maintain only a single file in your source state, you can use a shared template.\nCreate the common file in the .chezmoitemplates directory in the source state. For example, create .chezmoitemplates/file.conf. The contents of this file are available in templates with the template *name* . function where name is the name of the file (. passes the current data to the template code in file.conf; see https://pkg.go.dev/text/template#hdr-Actions for details).\nThen create files for each system, for example Library/Application Support/App/file.conf.tmpl for macOS and dot_config/app/file.conf.tmpl for Linux. Both template files should contain {{- template \u0026quot;file.conf\u0026quot; . -}}.\nFinally, tell chezmoi to ignore files where they are not needed by adding lines to your .chezmoiignore file, for example:\n{{ if ne .chezmoi.os \u0026quot;darwin\u0026quot; }} Library/Application Support/App/file.conf {{ end }} {{ if ne .chezmoi.os \u0026quot;linux\u0026quot; }} .config/app/file.conf {{ end }}  Create an archive of your dotfiles #  chezmoi archive creates an archive containing the target state. This can be useful for generating target state for a different machine. You can specify a different configuration file (including template variables) with the --config option.\n Keep data private #  chezmoi automatically detects when files and directories are private when adding them by inspecting their permissions. Private files and directories are stored in ~/.local/share/chezmoi as regular, public files with permissions 0644 and the name prefix private_. For example:\n$ chezmoi add ~/.netrc will create ~/.local/share/chezmoi/private_dot_netrc (assuming ~/.netrc is not world- or group- readable, as it should be). This file is still private because ~/.local/share/chezmoi is not group- or world- readable or executable. chezmoi checks that the permissions of ~/.local/share/chezmoi are 0700 on every run and will print a warning if they are not.\nIt is common that you need to store access tokens in config files, e.g. a GitHub access token. There are several ways to keep these tokens secure, and to prevent them leaving your machine.\n Use 1Password #  chezmoi includes support for 1Password using the 1Password CLI to expose data as a template function.\nLog in and get a session using:\n$ eval $(op signin \u0026lt;subdomain\u0026gt;.1password.com \u0026lt;email\u0026gt;) The output of op get item \u0026lt;uuid\u0026gt; is available as the onepassword template function. chezmoi parses the JSON output and returns it as structured data. For example, if the output of op get item \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; is:\n{ \u0026#34;uuid\u0026#34;: \u0026#34;\u0026lt;uuid\u0026gt;\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;password\u0026#34;: \u0026#34;xxx\u0026#34; } } Then you can access details.password with the syntax:\n{{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }} Login details fields can be retrieved with the onepasswordDetailsFields function, for example:\n{{- (onepasswordDetailsFields \u0026quot;uuid\u0026quot;).password.value }} Documents can be retrieved with:\n{{- onepasswordDocument \u0026quot;uuid\u0026quot; -}} Note the extra - after the opening {{ and before the closing }}. This instructs the template language to remove any whitespace before and after the substitution. This removes any trailing newline added by your editor when saving the template.\n Use Bitwarden #  chezmoi includes support for Bitwarden using the Bitwarden CLI to expose data as a template function.\nLog in to Bitwarden using:\n$ bw login \u0026lt;bitwarden-email\u0026gt; Unlock your Bitwarden vault:\n$ bw unlock Set the BW_SESSION environment variable, as instructed.\nThe structured data from bw get is available as the bitwarden template function in your config files, for example:\nusername = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).login.password }} Custom fields can be accessed with the bitwardenFields template function. For example, if you have a custom field named token you can retrieve its value with:\n{{ (bitwardenFields \u0026quot;item\u0026quot; \u0026quot;example.com\u0026quot;).token.value }}  Use gopass #  chezmoi includes support for gopass using the gopass CLI.\nThe first line of the output of gopass show \u0026lt;pass-name\u0026gt; is available as the gopass template function, for example:\n{{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use KeePassXC #  chezmoi includes support for KeePassXC using the KeePassXC CLI (keepassxc-cli) to expose data as a template function.\nProvide the path to your KeePassXC database in your configuration file:\n[keepassxc] database = \u0026#34;/home/user/Passwords.kdbx\u0026#34; The structured data from keepassxc-cli show $database is available as the keepassxc template function in your config files, for example:\nusername = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }} Additional attributes are available through the keepassxcAttribute function. For example, if you have an entry called SSH Key with an additional attribute called private-key, its value is available as:\n{{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  Use Keychain or Windows Credentials Manager #  chezmoi includes support for Keychain (on macOS), GNOME Keyring (on Linux), and Windows Credentials Manager (on Windows) via the zalando/go-keyring library.\nSet values with:\n$ chezmoi secret keyring set --service=\u0026lt;service\u0026gt; --user=\u0026lt;user\u0026gt; Value: xxxxxxxx The value can then be used in templates using the keyring function which takes the service and user as arguments.\nFor example, save a GitHub access token in keyring with:\n$ chezmoi secret keyring set --service=github --user=\u0026lt;github-username\u0026gt; Value: xxxxxxxx and then include it in your ~/.gitconfig file with:\n[github] user = {{ .github.user | quote }} token = {{ keyring \u0026quot;github\u0026quot; .github.user | quote }} You can query the keyring from the command line:\n$ chezmoi secret keyring get --service=github --user=\u0026lt;github-username\u0026gt;  Use LastPass #  chezmoi includes support for LastPass using the LastPass CLI to expose data as a template function.\nLog in to LastPass using:\n$ lpass login \u0026lt;lastpass-username\u0026gt; Check that lpass is working correctly by showing password data:\n$ lpass show --json \u0026lt;lastpass-entry-id\u0026gt; where \u0026lt;lastpass-entry-id\u0026gt; is a LastPass Entry Specification.\nThe structured data from lpass show --json id is available as the lastpass template function. The value will be an array of objects. You can use the index function and .Field syntax of the text/template language to extract the field you want. For example, to extract the password field from first the \u0026ldquo;GitHub\u0026rdquo; entry, use:\ngithubPassword = {{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password | quote }} chezmoi automatically parses the note value of the Lastpass entry as colon-separated key-value pairs, so, for example, you can extract a private SSH key like this:\n{{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }} Keys in the note section written as CamelCase Words are converted to camelCaseWords.\nIf the note value does not contain colon-separated key-value pairs, then you can use lastpassRaw to get its raw value, for example:\n{{ (index (lastpassRaw \u0026quot;SSH Private Key\u0026quot;) 0).note }}  Use pass #  chezmoi includes support for pass using the pass CLI.\nThe first line of the output of pass show \u0026lt;pass-name\u0026gt; is available as the pass template function, for example:\n{{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  Use Vault #  chezmoi includes support for Vault using the Vault CLI to expose data as a template function.\nThe vault CLI needs to be correctly configured on your machine, e.g. the VAULT_ADDR and VAULT_TOKEN environment variables must be set correctly. Verify that this is the case by running:\n$ vault kv get -format=json \u0026lt;key\u0026gt; The structured data from vault kv get -format=json is available as the vault template function. You can use the .Field syntax of the text/template language to extract the data you want. For example:\n{{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  Use a custom password manager #  You can use any command line tool that outputs secrets either as a string or in JSON format. Choose the binary by setting secret.command in your configuration file. You can then invoke this command with the secret and secretJSON template functions which return the raw output and JSON-decoded output respectively. All of the above secret managers can be supported in this way:\n   Secret Manager secret.command Template skeleton     1Password op {{ secretJSON \u0026quot;get\u0026quot; \u0026quot;item\u0026quot; \u0026lt;id\u0026gt; }}   Bitwarden bw {{ secretJSON \u0026quot;get\u0026quot; \u0026lt;id\u0026gt; }}   HashiCorp Vault vault {{ secretJSON \u0026quot;kv\u0026quot; \u0026quot;get\u0026quot; \u0026quot;-format=json\u0026quot; \u0026lt;id\u0026gt; }}   LastPass lpass {{ secretJSON \u0026quot;show\u0026quot; \u0026quot;--json\u0026quot; \u0026lt;id\u0026gt; }}   KeePassXC keepassxc-cli Not possible (interactive command only)   pass pass {{ secret \u0026quot;show\u0026quot; \u0026lt;id\u0026gt; }}     Encrypt whole files with gpg #  chezmoi supports encrypting files with gpg. Encrypted files are stored in the source state and automatically be decrypted when generating the target state or printing a file\u0026rsquo;s contents with chezmoi cat. chezmoi edit will transparently decrypt the file before editing and re-encrypt it afterwards.\n Asymmetric (private/public-key) encryption #  Specify the encryption key to use in your configuration file (chezmoi.toml) with the gpg.recipient key:\nencryption = \u0026#34;gpg\u0026#34; [gpg] recipient = \u0026#34;...\u0026#34; Add files to be encrypted with the --encrypt flag, for example:\n$ chezmoi add --encrypt ~/.ssh/id_rsa chezmoi will encrypt the file with:\ngpg --armor --recipient ${gpg.recipient} --encrypt and store the encrypted file in the source state. The file will automatically be decrypted when generating the target state.\n Symmetric encryption #  Specify symmetric encryption in your configuration file:\nencryption = \u0026#34;gpg\u0026#34; [gpg] symmetric = true Add files to be encrypted with the --encrypt flag, for example:\n$ chezmoi add --encrypt ~/.ssh/id_rsa chezmoi will encrypt the file with:\ngpg --armor --symmetric  Encrypt whole files with age #  chezmoi supports encrypting files with age. Encrypted files are stored in the source state and automatically be decrypted when generating the target state or printing a file\u0026rsquo;s contents with chezmoi cat. chezmoi edit will transparently decrypt the file before editing and re-encrypt it afterwards.\nGenerate a key using age-keygen:\n$ age-keygen -o $HOME/key.txt Public key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p Specify age encryption in your configuration file, being sure to specify at least the identity and one recipient:\nencryption = \u0026#34;age\u0026#34; [age] identity = \u0026#34;/home/user/key.txt\u0026#34; recipient = \u0026#34;age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p\u0026#34; Add files to be encrypted with the --encrypt flag, for example:\n$ chezmoi add --encrypt ~/.ssh/id_rsa chezmoi supports multiple recipients and recipient files, and multiple identities.\n Symmetric encryption #  To use age\u0026rsquo;s symmetric encryption, specify a single identity and enable symmetric encryption in your config file, for example:\nencryption = \u0026#34;age\u0026#34; [age] identity = \u0026#34;~/.ssh/id_rsa\u0026#34; symmetric = true  Symmetric encryption with a passphrase #  To use age\u0026rsquo;s symmetric encryption with a passphrase, set age.passphrase to true in your config file, for example:\nencryption = \u0026#34;age\u0026#34; [age] passphrase = true You will be prompted for the passphrase whenever you run chezmoi add --encrypt and whenever chezmoi needs to decrypt the file, for example when you run chezmoi apply, chezmoi diff, or chezmoi status.\n Use a private configuration file and template variables #  Typically, ~/.config/chezmoi/chezmoi.toml is not checked in to version control and has permissions 0600. You can store tokens as template values in the data section. For example, if your ~/.config/chezmoi/chezmoi.toml contains:\n[data.github] user = \u0026#34;\u0026lt;github-username\u0026gt;\u0026#34; token = \u0026#34;\u0026lt;github-token\u0026gt;\u0026#34; Your ~/.local/share/chezmoi/private_dot_gitconfig.tmpl can then contain:\n{{- if (index . \u0026quot;github\u0026quot;) }} [github] user = {{ .github.user | quote }} token = {{ .github.token | quote }} {{- end }} Any config files containing tokens in plain text should be private (permissions 0600).\n Use scripts to perform actions #   Understand how scripts work #  chezmoi supports scripts, which are executed when you run chezmoi apply. The scripts can either run every time you run chezmoi apply, or only when their contents have changed.\nIn verbose mode, the script\u0026rsquo;s contents will be printed before executing it. In dry-run mode, the script is not executed.\nScripts are any file in the source directory with the prefix run_, and are executed in alphabetical order. Scripts that should only be run if they have not been run before have the prefix run_once_. Scripts that should be run whenever their contents change have the run_onchange_ prefix.\nScripts break chezmoi\u0026rsquo;s declarative approach, and as such should be used sparingly. Any script should be idempotent, even run_once_ and run_onchange_ scripts.\nScripts must be created manually in the source directory, typically by running chezmoi cd and then creating a file with a run_ prefix. Scripts are executed directly using exec and must include a shebang line or be executable binaries. There is no need to set the executable bit on the script.\nScripts with the suffix .tmpl are treated as templates, with the usual template variables available. If, after executing the template, the result is only whitespace or an empty string, then the script is not executed. This is useful for disabling scripts.\n Install packages with scripts #  Change to the source directory and create a file called run_once_install-packages.sh:\n$ chezmoi cd $ $EDITOR run_once_install-packages.sh In this file create your package installation script, e.g.\n#!/bin/sh sudo apt install ripgrep The next time you run chezmoi apply or chezmoi update this script will be run. As it has the run_once_ prefix, it will not be run again unless its contents change, for example if you add more packages to be installed.\nThis script can also be a template. For example, if you create run_once_install-packages.sh.tmpl with the contents:\n{{ if eq .chezmoi.os \u0026quot;linux\u0026quot; -}} #!/bin/sh sudo apt install ripgrep {{ else if eq .chezmoi.os \u0026quot;darwin\u0026quot; -}} #!/bin/sh brew install ripgrep {{ end -}} This will install ripgrep on both Debian/Ubuntu Linux systems and macOS.\n Run a script when the contents of another file changes #  chezmoi\u0026rsquo;s run_ scripts are run every time you run chezmoi apply, whereas run_once_ scripts are run only when their contents have changed, after executing them as templates. You use this to cause a run_once_ script to run when the contents of another file has changed by including a checksum of the other file\u0026rsquo;s contents in the script.\nFor example, if your dconf settings are stored in dconf.ini in your source directory then you can make chezmoi apply only load them when the contents of dconf.ini has changed by adding the following script as run_once_dconf-load.sh.tmpl:\n#!/bin/bash # dconf.ini hash: {{ include \u0026quot;dconf.ini\u0026quot; | sha256sum }} dconf load / {{ joinPath .chezmoi.sourceDir \u0026quot;dconf.ini\u0026quot; | quote }} As the SHA256 sum of dconf.ini is included in a comment in the script, the contents of the script will change whenever the contents of dconf.ini are changed, so chezmoi will re-run the script whenever the contents of dconf.ini change.\nIn this example you should also add dconf.ini to .chezmoiignore so chezmoi does not create dconf.ini in your home directory.\n Use chezmoi on macOS #   Use brew bundle to manage your brews and casks #  Homebrew\u0026rsquo;s brew bundle subcommand allows you to specify a list of brews and casks to be installed. You can integrate this with chezmoi by creating a run_once_ script. For example, create a file in your source directory called run_once_before_install-packages-darwin.sh.tmpl containing:\n{{- if (eq .chezmoi.os \u0026quot;darwin\u0026quot;) -}} #!/bin/bash brew bundle --no-lock --file=/dev/stdin \u0026lt;\u0026lt;EOF brew \u0026quot;git\u0026quot; cask \u0026quot;google-chrome\u0026quot; EOF {{ end -}} Note that the Brewfile is embedded directly in the script with a bash here document. chezmoi will run this script whenever its contents change, i.e. when you add or remove brews or casks.\n Use chezmoi on Windows #   Detect Windows Subsystem for Linux (WSL) #  WSL can be detected by looking for the string Microsoft or microsoft in /proc/sys/kernel/osrelease, which is available in the template variable .chezmoi.kernel.osrelease, for example:\n{{ if (eq .chezmoi.os \u0026quot;linux\u0026quot;) }} {{ if (.chezmoi.kernel.osrelease | lower | contains \u0026quot;microsoft\u0026quot;) }} # WSL-specific code {{ end }} {{ end }}  Run a PowerShell script as admin on Windows #  Put the following at the top of your script:\n# Self-elevate the script if required if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \u0026#39;Administrator\u0026#39;)) { if ([int](Get-CimInstance -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) { $CommandLine = \u0026#34;-NoExit -File `\u0026#34;\u0026#34; + $MyInvocation.MyCommand.Path + \u0026#34;`\u0026#34;\u0026#34; + $MyInvocation.UnboundArguments Start-Process -FilePath PowerShell.exe -Verb Runas -ArgumentList $CommandLine Exit } }  Use chezmoi with GitHub Codespaces, Visual Studio Codespaces, or Visual Studio Code Remote - Containers #  The following assumes you are using chezmoi 1.8.4 or later. It does not work with earlier versions of chezmoi.\nYou can use chezmoi to manage your dotfiles in GitHub Codespaces, Visual Studio Codespaces, and Visual Studio Code Remote - Containers.\nFor a quick start, you can clone the chezmoi/dotfiles repository which supports Codespaces out of the box.\nThe workflow is different to using chezmoi on a new machine, notably:\n These systems will automatically clone your dotfiles repo to ~/dotfiles, so there is no need to clone your repo yourself. The installation script must be non-interactive. When running in a Codespace, the environment variable CODESPACES will be set to true. You can read its value with the env template function.  First, if you are using a chezmoi configuration file template, ensure that it is non-interactive when running in Codespaces, for example, .chezmoi.toml.tmpl might contain:\n{{- $codespaces:= env \u0026quot;CODESPACES\u0026quot; | not | not -}} sourceDir = {{ .chezmoi.sourceDir | quote }} [data] name = \u0026quot;Your name\u0026quot; codespaces = {{ $codespaces }} {{- if $codespaces }}{{/* Codespaces dotfiles setup is non-interactive, so set an email address */}} email = \u0026quot;your@email.com\u0026quot; {{- else }}{{/* Interactive setup, so prompt for an email address */}} email = {{ promptString \u0026quot;email\u0026quot; | quote }} {{- end }} This sets the codespaces template variable, so you don\u0026rsquo;t have to repeat (env \u0026quot;CODESPACES\u0026quot;) in your templates. It also sets the sourceDir configuration to the --source argument passed in chezmoi init.\nSecond, create an install.sh script that installs chezmoi and your dotfiles:\n#!/bin/sh  set -e # -e: exit on error if [ ! \u0026#34;$(command -v chezmoi)\u0026#34; ]; then bin_dir=\u0026#34;$HOME/.local/bin\u0026#34; chezmoi=\u0026#34;$bin_dir/chezmoi\u0026#34; if [ \u0026#34;$(command -v curl)\u0026#34; ]; then sh -c \u0026#34;$(curl -fsLS https://git.io/chezmoi)\u0026#34; -- -b \u0026#34;$bin_dir\u0026#34; elif [ \u0026#34;$(command -v wget)\u0026#34; ]; then sh -c \u0026#34;$(wget -qO- https://git.io/chezmoi)\u0026#34; -- -b \u0026#34;$bin_dir\u0026#34; else echo \u0026#34;To install chezmoi, you must have curl or wget installed.\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi else chezmoi=chezmoi fi # POSIX way to get script\u0026#39;s dir: https://stackoverflow.com/a/29834779/12156188 script_dir=\u0026#34;$(cd -P -- \u0026#34;$(dirname -- \u0026#34;$(command -v -- \u0026#34;$0\u0026#34;)\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd -P)\u0026#34; # exec: replace current process with chezmoi init exec \u0026#34;$chezmoi\u0026#34; init --apply \u0026#34;--source=$script_dir\u0026#34; Ensure that this file is executable (chmod a+x install.sh), and add install.sh to your .chezmoiignore file.\nIt installs the latest version of chezmoi in ~/.local/bin if needed, and then chezmoi init ... invokes chezmoi to create its configuration file and initialize your dotfiles. --apply tells chezmoi to apply the changes immediately, and --source=... tells chezmoi where to find the cloned dotfiles repo, which in this case is the same folder in which the script is running from.\nIf you do not use a chezmoi configuration file template you can use chezmoi apply --source=$HOME/dotfiles instead of chezmoi init ... in install.sh.\nFinally, modify any of your templates to use the codespaces variable if needed. For example, to install vim-gtk on Linux but not in Codespaces, your run_once_install-packages.sh.tmpl might contain:\n{{- if (and (eq .chezmoi.os \u0026quot;linux\u0026quot;) (not .codespaces)) -}} #!/bin/sh sudo apt install -y vim-gtk {{- end -}}  Customize chezmoi #   Use a subdirectory of your dotfiles repo as the root of the source state #  By default, chezmoi uses the root of your dotfiles repo as the root of the source state. If your source state contains many entries in its root, then your target directory (usually your home directory) will in turn be filled with many entries in its root as well. You can reduce the number of entries by keeping .chezmoiignore up to date, but this can become tiresome.\nInstead, you can specify that chezmoi should read the source state from a subdirectory of the source directory instead by creating a file called .chezmoiroot containing the relative path to this subdirectory.\nFor example, if .chezmoiroot contains:\nhome Then chezmoi will read the source state from the home subdirectory of your source directory, for example the desired state of ~/.gitconfig will be read from ~/.local/share/chezmoi/home/dot_gitconfig (instead of ~/.local/share/chezmoi/dot_gitconfig).\nWhen migrating an existing chezmoi dotfiles repo to use .chezmoiroot you will need to move the relevant files in to the new root subdirectory manually. You do not need to move files that are ignored by chezmoi in all cases (i.e. are listed in .chezmoiignore when executed as a template on all machines), and you can afterwards remove their entries from home/.chezmoiignore.\n Don\u0026rsquo;t show scripts in the diff output #  By default, chezmoi diff will show all changes, including the contents of scripts that will be run. You can exclude scripts from the diff output by setting the diff.exclude configuration variable in your configuration file, for example:\n[diff] exclude = [\u0026#34;scripts\u0026#34;]  Customize the diff pager #  You can change the diff format, and/or pipe the output into a pager of your choice by setting diff.pager configuration variable. For example, to use diff-so-fancy specify:\n[diff] pager = \u0026#34;diff-so-fancy\u0026#34; The pager can be disabled using the --no-pager flag or by setting diff.pager to an empty string.\n Use a custom diff tool #  By default, chezmoi uses a built-in diff. You can use a custom tool by setting the diff.command and diff.args configuration variables. The elements of diff.args are interpreted as templates with the variables .Destination and .Target containing filenames of the file in the destination state and the target state respectively. For example, to use meld, specify:\n[diff] command = \u0026#34;meld\u0026#34; args = [\u0026#34;--diff\u0026#34;, \u0026#34;{{ .Destination }}\u0026#34;, \u0026#34;{{ .Target }}\u0026#34;]  Use a custom merge tool #  By default, chezmoi uses vimdiff. You can use a custom tool by setting the merge.command and merge.args configuration variables. The elements of merge.args are interprested as templates with the variables .Destination, .Source, and .Target containing filenames of the file in the destination state, source state, and target state respectively. For example, to use neovim\u0026rsquo;s diff mode, specify:\n[merge] command = \u0026#34;nvim\u0026#34; args = [\u0026#34;-d\u0026#34;, \u0026#34;{{ .Destination }}\u0026#34;, \u0026#34;{{ .Source }}\u0026#34;, \u0026#34;{{ .Target }}\u0026#34;]  Use an HTTP or SOCKS5 proxy #  chezmoi supports HTTP, HTTPS, and SOCKS5 proxies. Set the HTTP_PROXY, HTTPS_PROXY, and NO_PROXY environment variables, or their lowercase equivalents, for example:\n$ HTTP_PROXY=socks5://127.0.0.1:1080 chezmoi apply -R  Migrating to chezmoi from another dotfile manager #   Migrate from a dotfile manager that uses symlinks #  Many dotfile managers replace dotfiles with symbolic links to files in a common directory. If you chezmoi add such a symlink, chezmoi will add the symlink, not the file. To assist with migrating from symlink-based systems, use the --follow option to chezmoi add, for example:\n$ chezmoi add --follow ~/.bashrc This will tell chezmoi add that the target state of ~/.bashrc is the target of the ~/.bashrc symlink, rather than the symlink itself. When you run chezmoi apply, chezmoi will replace the ~/.bashrc symlink with the file contents.\n Migrate away from chezmoi #  chezmoi provides several mechanisms to help you move to an alternative dotfile manager (or even no dotfile manager at all) in the future:\n chezmoi creates your dotfiles just as if you were not using a dotfile manager at all. Your dotfiles are regular files, directories, and symlinks. You can run chezmoi purge to delete all traces of chezmoi and then, if you\u0026rsquo;re migrating to a new dotfile manager, then you can use whatever mechanism it provides to add your dotfiles to your new system. chezmoi has a chezmoi archive command that generates a tarball of your dotfiles. You can replace the contents of your dotfiles repo with the contents of the archive and you\u0026rsquo;ve effectively immediately migrated away from chezmoi. chezmoi has a chezmoi dump command that dumps the interpreted (target) state in a machine-readable form, so you can write scripts around chezmoi.  "},{"id":6,"href":"/docs/install/","title":"Install","section":"Docs","content":"Install Guide #   One-line binary install #  Install the correct binary for your operating system and architecture in ./bin with a single command:\n$ sh -c \u0026#34;$(curl -fsLS git.io/chezmoi)\u0026#34; Or, if you have wget instead of curl:\n$ sh -c \u0026#34;$(wget -qO- git.io/chezmoi)\u0026#34; If you already have a dotfiles repo using chezmoi on GitHub at https://github.com/\u0026lt;github-username\u0026gt;/dotfiles then you can install chezmoi and your dotfiles with the single command:\n$ sh -c \u0026#34;$(curl -fsLS git.io/chezmoi)\u0026#34; -- init --apply \u0026lt;github-username\u0026gt; Or on systems with Powershell, you can use one of the following command:\n# To install in ./bin (iwr -UseBasicParsing https://git.io/chezmoi.ps1).Content | powershell -c - # To install in another location '$params = \u0026quot;-BinDir ~/other\u0026quot;', (iwr https://git.io/chezmoi.ps1).Content | powershell -c - # For information about other options, run '$params = \u0026quot;-?\u0026quot;', (iwr https://git.io/chezmoi.ps1).Content | powershell -c -  One-line package install #  Install chezmoi with a single command.\n   OS Method Command     Linux snap snap install chezmoi --classic   Linux Linuxbrew brew install chezmoi   Alpine Linux apk apk add chezmoi   Arch Linux pacman pacman -S chezmoi   Guix Linux guix guix install chezmoi   OpenIndiana pkg pkg install application/chezmoi   NixOS Linux nix-env nix-env -i chezmoi   Void Linux xbps xbps-install -S chezmoi   macOS Homebrew brew install chezmoi   macOS MacPorts port install chezmoi   Windows Scoop scoop bucket add twpayne https://github.com/twpayne/scoop-bucket \u0026amp;\u0026amp; scoop install chezmoi   Windows Chocolatey choco install chezmoi   FreeBSD pkg pkg install chezmoi     Pre-built Linux packages #  Download a package for your operating system and architecture and install it with your package manager.\n   Distribution Architectures Package     Alpine 386, amd64, arm64, arm, ppc64, ppc64le apk   Debian amd64, arm64, armel, i386, ppc64, ppc64le deb   RedHat aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   OpenSUSE aarch64, armhfp, i686, ppc64, ppc64le, x86_64 rpm   Ubuntu amd64, arm64, armel, i386, ppc64, ppc64le deb     Pre-built binaries #  Download an archive for your operating system containing a pre-built binary, documentation, and shell completions.\n   OS Architectures Archive     FreeBSD amd64, arm, arm64, i386 tar.gz   Illumos amd64 tar.gz   Linux amd64, arm, arm64, i386, ppc64, ppc64le tar.gz   macOS amd64, arm64 tar.gz   OpenBSD amd64, arm, arm64, i386 tar.gz   Solaris amd64 tar.gz   Windows amd64, arm, i386 zip     All pre-built Linux packages and binaries #  All pre-built binaries and packages can be found on the chezmoi GitHub releases page.\n From source #  Download, build, and install chezmoi for your system:\n$ git clone https://github.com/twpayne/chezmoi.git $ cd chezmoi $ make install Building chezmoi requires Go 1.16 or later.\n "},{"id":7,"href":"/docs/media/","title":"Media","section":"Docs","content":"Media #  Recommended article: Fedora Magazine: Take back your dotfiles with Chezmoi\nRecommended video: chezmoi: manage your dotfiles across multiple, diverse machines, securely\nRecommended podcast: Managing Dot Files and an Introduction to Chezmoi\n    Date Version Format Link     2021-10-26 2.7.3 Text (RU) Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ñ‹Ñ… Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐº   2021-09-18 2.1.2 Audio/text PBS 125 of X â€” Chezmoi on Multiple Computers   2021-09-14 2.2.0 Text Managing preference plists under Chezmoi   2021-09-06 2.2.0 Video chezmoi: Organize your dotfiles across multiple computers | Let\u0026rsquo;s Code   2021-09-06 2.2.0 Text chezmoi dotfile management   2021-09-04 2.2.0 Text Configuration Management   2021-09-04 2.1.2 Audio/text PBS 124 of X â€” Chezmoi Templates   2021-08-22 2.1.2 Audio/text PBS 123 of X â€” Backing up and Syncing Dot Files with Chezmoi   2021-08-08 2.1.2 Audio/text PBS 122 of X â€” Managing Dot Files with Chezmoi   2021-07-23 2.1.2 Audio/text PBS 121 of X â€” Managing Dot Files and an Introduction to Chezmoi   2021-07-15 2.1.2 Text (CN) ä½¿ç”¨Chezmoiç®¡ç†é…ç½®æ–‡ä»¶   2021-05-14 2.0.12 Text A brief history of my dotfile management   2021-05-12 2.0.12 Text My Dotfiles Story: A Journey to Chezmoi   2021-05-10 2.0.11 Text Development Environment (2021)   2021-04-20 2.0.9 Text ChezMoi   2021-04-08 2.0.9 Text (FR) Bienvenue chez moi   2021-04-01 2.0.7 Text ChezMoi   2021-02-17 1.8.11 Text (JP) chezmoi ã§ dotfiles ã‚’æ‰‹è»½ã«æŸ”è»Ÿã«ã‚»ã‚­ãƒ¥ã‚¢ã«ç®¡ç†ã™ã‚‹   2021-02-07 1.8.10 Text (JP) chezmoiå§‹ã‚ãŸ   2021-02-06 1.8.10 Video chezmoi: manage your dotfiles across multiple, diverse machines, securely   2021-01-29 1.8.10 Text (CN) [å½’æ¡£] ç”¨ Chezmoi ç®¡ç†é…ç½®æ–‡ä»¶   2021-01-12 1.8.10 Text Automating the Setup of a New Mac With All Your Apps, Preferences, and Development Tools   2020-11-06 1.8.8 Text Chezmoi â€“ Securely Manage dotfiles across multiple machines   2020-11-05 1.8.8 Text Using chezmoi to manage dotfiles   2020-10-05 1.8.6 Text Dotfiles with Chezmoi   2020-10-03 1.8.6 Text Chezmoi Merging   2020-08-13 1.8.3 Text Using BitWarden and Chezmoi to manage SSH keys   2020-08-09 1.8.3 Text Automating and testing dotfiles   2020-08-03 1.8.3 Text Automating a Linux in Windows Dev Setup   2020-07-06 1.8.3 Video Conf42: chezmoi: Manage your dotfiles across multiple machines, securely   2020-07-03 1.8.3 Text Feeling at home in a LXD container   2020-06-15 1.8.2 Text Dotfiles management using chezmoi - How I Use Linux Desktop at Work Part5   2020-04-27 1.8.0 Text Managing my dotfiles with chezmoi   2020-04-20 1.8.0 Text (FR) Gestion des dotfiles et des secrets avec chezmoi   2020-04-19 1.7.19 Text (FR) Git \u0026amp; dotfiles : versionner ses fichiers de configuration   2020-04-16 1.7.19 Text (FR) Chezmoi, visite guidÃ©e   2020-04-17 1.7.17 Text (CN) [ç”¨ Chezmoi å–å›žä½ çš„ç‚¹æ–‡ä»¶   2020-04-03 1.7.17 Text Fedora Magazine: Take back your dotfiles with Chezmoi   2020-04-01 1.7.17 Text Managing dotfiles and secret with chezmoi   2020-03-12 1.7.16 Video Managing Dotfiles with ChezMoi   2019-11-20 1.7.2 Audio/video FLOSS weekly episode 556: chezmoi   2019-01-10 0.0.11 Text Linux Fu: The kitchen sync     To add your article to this page please either open an issue or submit a pull request that modifies this file (docs/MEDIA.md).\n "},{"id":8,"href":"/docs/quick-start/","title":"Quick Start","section":"Docs","content":"Quick Start Guide #   Concepts #  chezmoi stores the desired state of your dotfiles in the directory ~/.local/share/chezmoi. When you run chezmoi apply, chezmoi calculates the desired contents and permissions for each dotfile and then makes any changes necessary so that your dotfiles match that state.\n Start using chezmoi on your current machine #  Assuming that you have already installed chezmoi, initialize chezmoi with:\n$ chezmoi init This will create a new git repository in ~/.local/share/chezmoi where chezmoi will store its source state. By default, chezmoi only modifies files in the working copy. It is your responsibility to commit and push changes, but chezmoi can automate this for you if you want.\nManage your first file with chezmoi:\n$ chezmoi add ~/.bashrc This will copy ~/.bashrc to ~/.local/share/chezmoi/dot_bashrc.\nEdit the source state:\n$ chezmoi edit ~/.bashrc This will open ~/.local/share/chezmoi/dot_bashrc in your $EDITOR. Make some changes and save the file.\nSee what changes chezmoi would make:\n$ chezmoi diff Apply the changes:\n$ chezmoi -v apply All chezmoi commands accept the -v (verbose) flag to print out exactly what changes they will make to the file system, and the -n (dry run) flag to not make any actual changes. The combination -n -v is very useful if you want to see exactly what changes would be made.\nNext, open a shell in the source directory, to commit your changes:\n$ chezmoi cd $ git add . $ git commit -m \u0026#34;Initial commit\u0026#34; Create a new repository on GitHub called dotfiles and then push your repo:\n$ git remote add origin git@github.com:username/dotfiles.git $ git branch -M main $ git push -u origin main chezmoi can also be used with GitLab, or BitBucket, Source Hut, or any other git hosting service.\nFinally, exit the shell in the source directory to return to where you were:\n$ exit  Using chezmoi across multiple machines #  On a second machine, initialize chezmoi with your dotfiles repo:\n$ chezmoi init https://github.com/username/dotfiles.git This will check out the repo and any submodules and optionally create a chezmoi config file for you.\nCheck what changes that chezmoi will make to your home directory by running:\n$ chezmoi diff If you are happy with the changes that chezmoi will make then run:\n$ chezmoi apply -v If you are not happy with the changes to a file then either edit it with:\n$ chezmoi edit $FILE Or, invoke a merge tool (by default vimdiff) to merge changes between the current contents of the file, the file in your working copy, and the computed contents of the file:\n$ chezmoi merge $FILE On any machine, you can pull and apply the latest changes from your repo with:\n$ chezmoi update -v  Next steps #  For a full list of commands run:\n$ chezmoi help chezmoi has much more functionality. Good starting points are reading articles about chezmoi adding more dotfiles, and using templates to manage files that vary from machine to machine and retrieve secrets from your password manager. Read the how-to guide to explore.\n "},{"id":9,"href":"/docs/reference/","title":"Reference","section":"Docs","content":"Reference Manual #   Concepts #  chezmoi evaluates the source state for the current machine and then updates the destination directory, where:\n  The source state declares the desired state of your home directory, including templates and machine-specific configuration.\n  The source directory is where chezmoi stores the source state, by default ~/.local/share/chezmoi.\n  The target state is the source state computed for the current machine.\n  The destination directory is the directory that chezmoi manages, by default your home directory.\n  A target is a file, directory, or symlink in the destination directory.\n  The destination state is the current state of all the targets in the destination directory.\n  The config file contains machine-specific configuration, by default it is ~/.config/chezmoi/chezmoi.toml.\n  The working tree is the git working tree. Normally it is the same as the source directory, but can be a parent of the source directory.\n   Global command line flags #  Command line flags override any values set in the configuration file.\n--color value #  Colorize diffs, value can be on, off, auto, or any boolean-like value recognized by parseBool. The default is auto which will colorize diffs only if the the environment variable $NO_COLOR is not set and stdout is a terminal.\n-c, --config filename #  Read the configuration from filename.\n--config-format json|toml|yaml #  Assume the configuration file is in the given format. This is only needed if the config filename does not have an extension, for example when it is /dev/stdin.\n-D, --destination directory #  Use directory as the destination directory.\n-n, --dry-run #  Set dry run mode. In dry run mode, the destination directory is never modified. This is most useful in combination with the -v (verbose) flag to print changes that would be made without making them.\n--force #  Make changes without prompting.\n-h, --help #  Print help.\n-k, --keep-going #  Keep going as far as possible after a encountering an error.\n--no-pager #  Do not use the pager.\n--no-tty #  Do not attempt to get a TTY to read input and passwords. Instead, read them from stdin.\n-o, --output filename #  Write the output to filename instead of stdout.\n--persistent-state filename #  Read and write the persistent state from filename. By default, chezmoi stores its persistent state in chezmoistate.boltdb in the same directory as its configuration file.\n-R, --refresh-externals #  Refresh externals cache. See .chezmoiexternal.\u0026lt;format\u0026gt;.\n-S, --source directory #  Use directory as the source directory.\n--use-builtin-age value #  Use chezmoi\u0026rsquo;s builtin age encryption instead of an external age command. value can be on, off, auto, or any boolean-like value recognized by parseBool. The default is auto which will only use the builtin age if age.command cannot be found in $PATH.\nThe builtin age command does not support passphrases, symmetric encryption, or the use of SSH keys.\n--use-builtin-git value #  Use chezmoi\u0026rsquo;s builtin git instead of git.command for the init and update commands. value can be on, off, auto, or any boolean-like value recognized by parseBool. The default is auto which will only use the builtin git if git.command cannot be found in $PATH.\n-v, --verbose #  Set verbose mode. In verbose mode, chezmoi prints the changes that it is making as approximate shell commands, and any differences in files between the target state and the destination set are printed as unified diffs.\n--version #  Print the version of chezmoi, the commit at which it was built, and the build timestamp.\n-w, --working-tree directory #  Use directory as the git working tree directory. By default, chezmoi searches the source directory and then its ancestors for the first directory that contains a .git directory.\n Common command line flags #  The following flags apply to multiple commands where they are relevant.\n-f, --format json|yaml #  Set the output format.\n-i, --include types #  Only operate on target state entries of type types. types is a comma-separated list of target states (all, dirs, files, remove, scripts, symlinks, and encrypted) and can be excluded by preceding them with a no. For example, --include=dirs,files will cause the command to apply to directories and files only.\n--init #  Regenerate and reread the config file from the config file template before computing the target state.\n-r, --recursive #  Recurse into subdirectories, true by default.\n-x, --exclude types #  Exclude target state entries of type types. types is a comma-separated list of target states (all, dirs, files, remove, scripts, symlinks, and encrypted). For example, --exclude=scripts will cause the command to not run scripts and --exclude=encrypted will exclude encrypted files.\nDeveloper command line flags #  The following flags are global but only relevant for developers and debugging.\n--cpu-profile filename #  Write a Go CPU profile to filename.\n--debug #  Log information helpful for debugging.\n--gops #  Enable the gops agent.\n Configuration file #  chezmoi searches for its configuration file according to the XDG Base Directory Specification and supports all formats supported by github.com/spf13/viper, namely JSON, TOML, YAML, macOS property file format, and HCL. The basename of the config file is chezmoi, and the first config file found is used.\nIn most installations, the config file will be read from ~/.config/chezmoi/chezmoi.\u0026lt;format\u0026gt;, where \u0026lt;format\u0026gt; is one of json, toml, or yaml. The config file can be set explicitly with the --config command line option. By default, the format is detected based on the extension of the config file name, but can be overridden with the --config-format command line option.\nVariables #  The following configuration variables are available:\n   Section Variable Type Default value Description     Top level color string auto Colorize output    data any none Template data    destDir string ~ Destination directory    encryption string none Encryption tool, either age or gpg    format string json Format for data output, either json or yaml    mode string file Mode in target dir, either file or symlink    sourceDir string ~/.local/share/chezmoi Source directory    pager string $PAGER Default pager    umask int from system Umask    useBuiltinAge string auto Use builtin age if age command is not found in $PATH    useBuiltinGit string auto Use builtin git if git command is not found in $PATH    workingTree string source directory git working tree directory   add templateSymlinks bool false Template symlinks to source and home dirs   age args []string none Extra args to age CLI command    command string age age CLI command    identity string none age identity file    identities []string none age identity files    passphrase bool false Use age passphrase instead of identity    recipient string none age recipient    recipients []string none age recipients    recipientsFile []string none age recipients file    recipientsFiles []string none age recipients files    suffix string .age Suffix appended to age-encrypted files    symmetric bool false Use age symmetric encryption   bitwarden command string bw Bitwarden CLI command   cd args []string none Extra args to shell in cd command    command string none Shell to run in cd command   diff args []string see diff below Extra args to external diff command    command string none External diff command    exclude []string none Entry types to exclude from diff    pager string none Diff-specific pager   docs maxWidth int 80 Maximum width of output    pager string none Docs-specific pager   edit args []string none Extra args to edit command    command string $EDITOR / $VISUAL Edit command    minDuration duration 1s Minimum duration for edit command   secret command string none Generic secret command   git autoAdd  bool false Add changes to the source state after any change    autoCommit bool false Commit changes to the source state after any change    autoPush bool false Push changes to the source state after any change    command string git Source version control system   gopass command string gopass gopass CLI command   gpg args []string none Extra args to GPG CLI command    command string gpg GPG CLI command    recipient string none GPG recipient    suffix string .asc Suffix appended to GPG-encrypted files    symmetric bool false Use symmetric GPG encryption   interpreters extension.args []string none See section on \u0026ldquo;Scripts on Windows\u0026rdquo;    extension.command string special See section on \u0026ldquo;Scripts on Windows\u0026rdquo;   keepassxc args []string none Extra args to KeePassXC CLI command    command string keepassxc-cli KeePassXC CLI command    database string none KeePassXC database   lastpass command string lpass Lastpass CLI command   merge args []string see merge below Args to 3-way merge command    command string vimdiff 3-way merge command   onepassword cache bool true Enable optional caching provided by op    command string op 1Password CLI command   pass command string pass Pass CLI command   pinentry args []string none Extra args to the pinentry command    command string none pinentry command    options []string see pinentry below Extra options for pinentry   template options []string [\u0026quot;missingkey=error\u0026quot;] Template options   vault command string vault Vault CLI command    Examples #  JSON #  { \u0026#34;sourceDir\u0026#34;: \u0026#34;/home/user/.dotfiles\u0026#34;, \u0026#34;git\u0026#34;: { \u0026#34;autoPush\u0026#34;: true } } TOML #  sourceDir = \u0026#34;/home/user/.dotfiles\u0026#34; [git] autoPush = true YAML #  sourceDir: /home/user/.dotfiles git: autoPush: true  Source state attributes #  chezmoi stores the source state of files, symbolic links, and directories in regular files and directories in the source directory (~/.local/share/chezmoi by default). This location can be overridden with the -S flag or by giving a value for sourceDir in ~/.config/chezmoi/chezmoi.toml. Directory targets are represented as directories in the source state. All other target types are represented as files in the source state. Some state is encoded in the source names.\nThe following prefixes and suffixes are special, and are collectively referred to as \u0026ldquo;attributes\u0026rdquo;:\n   Prefix Effect     after_ Run script after updating the destination.   before_ Run script before updating the destination.   create_ Ensure that the file exists, and create it with contents if it does not.   dot_ Rename to use a leading dot, e.g. dot_foo becomes .foo.   empty_ Ensure the file exists, even if is empty. By default, empty files are removed.   encrypted_ Encrypt the file in the source state.   exact_ Remove anything not managed by chezmoi.   executable_ Add executable permissions to the target file.   literal_ Stop parsing prefix attributes.   modify_ Treat the contents as a script that modifies an existing file.   once_ Only run the script if it has not been run before.   onchange_ Only run the script if its contents have changed from the last time it was run.   private_ Remove all group and world permissions from the target file or directory.   readonly_ Remove all write permissions from the target file or directory.   remove_ Remove the entry if it exists.   run_ Treat the contents as a script to run.   symlink_ Create a symlink instead of a regular file.       Suffix Effect     .literal Stop parsing suffix attributes.   .tmpl Treat the contents of the source file as a template.    Different target types allow different prefixes and suffixes. The order of prefixes is important.\n   Target type Source type Allowed prefixes in order Allowed suffixes     Directory Directory exact_, private_, readonly_, dot_ none   Regular file File encrypted_, private_, executable_, dot_ .tmpl   Create file File create_, encrypted_, private_, readonly_, executable_, dot_ .tmpl   Modify file File modify_, encrypted_, private_, readonly_, executable_, dot_ .tmpl   Remove File remove_, dot_ none   Script File run_, once_ or onchange_, before_ or after_ .tmpl   Symbolic link File symlink_, dot_, .tmpl    The literal_ prefix and .literal suffix can appear anywhere and stop attribute parsing. This permits filenames that would otherwise conflict with chezmoi\u0026rsquo;s attributes to be represented.\nIn addition, if the source file is encrypted, the suffix .age (when age encryption is used) or .asc (when gpg encryption is used) is stripped. These suffixes can be overridden with the age.suffix and gpg.suffix configuration variables.\nchezmoi ignores all files and directories in the source directory that begin with a . with the exception of files and directories that begin with .chezmoi.\n Target types #  chezmoi will create, update, and delete files, directories, and symbolic links in the destination directory, and run scripts. chezmoi deterministically performs actions in ASCII order of their target name. For example, given a file dot_a, a script run_z, and a directory exact_dot_c, chezmoi will first create .a, create .c, and then execute run_z.\n Files #  Files are represented by regular files in the source state. The encrypted_ attribute determines whether the file in the source state is encrypted. The executable_ attribute will set the executable bits in the the target state, and the private_ attribute will clear all group and world permissions. The readonly_ attribute will clear all write permission bits in the target state. Files with the .tmpl suffix will be interpreted as templates. If the target contents are empty then the file will be removed, unless it has an empty_ prefix.\nCreate file #  Files with the create_ prefix will be created in the target state with the contents of the file in the source state if they do not already exist. If the file in the destination state already exists then its contents will be left unchanged.\nModify file #  Files with the modify_ prefix are treated as scripts that modify an existing file. The contents of the existing file (which maybe empty if the existing file does not exist or is empty) are passed to the script\u0026rsquo;s standard input, and the new contents are read from the scripts standard output.\n Remove entry #  Files with the remove_ prefix will cause the corresponding entry (file, directory, or symlink) to be removed in the target state.\n Directories #  Directories are represented by regular directories in the source state. The exact_ attribute causes chezmoi to remove any entries in the target state that are not explicitly specified in the source state, and the private_ attribute causes chezmoi to clear all group and world permissions. The readonly_ attribute will clear all write permission bits.\n Symbolic links #  Symbolic links are represented by regular files in the source state with the prefix symlink_. The contents of the file will have a trailing newline stripped, and the result be interpreted as the target of the symbolic link. Symbolic links with the .tmpl suffix in the source state are interpreted as templates. If the target of the symbolic link is empty or consists only of whitespace, then the target is removed.\n Scripts #  Scripts are represented as regular files in the source state with prefix run_. The file\u0026rsquo;s contents (after being interpreted as a template if it has a .tmpl suffix) are executed.\nScripts are executed on every chezmoi apply, unless they have the once_ or onchange_ attribute. run_once_ scripts are only executed if a script with the same contents has not been run before, for example if its contents has changed. run_onchange_ scripts are executed whenever their contents change, even if a script with the same contents has run before.\nScripts with the before_ attribute are executed before any files, directories, or symlinks are updated. Scripts with the after_ attribute are executed after all files, directories, and symlinks have been updated. Scripts without an before_ or after_ attribute are executed in ASCII order of their target names with respect to files, directories, and symlinks.\nScripts will normally run with their working directory set to their equivalent location in the destination directory. For example, a script in ~/.local/share/chezmoi/dir/run_script will be run with a working directory of ~/dir. If the equivalent location in the destination directory either does not exist or is not a directory, then chezmoi will walk up the script\u0026rsquo;s directory hierarchy and run the script in the first directory that exists and is a directory.\nScripts on Windows #  The execution of scripts on Windows depends on the script\u0026rsquo;s file extension. Windows will natively execute scripts with a .bat, .cmd, .com, and .exe extensions. Other extensions require an interpreter, which must be in your %PATH%.\nThe default script interpreters are:\n   Extension Command Arguments     .pl perl none   .py python none   .ps1 powershell -NoLogo   .rb ruby none    Script interpreters can be added or overridden with the interpreters.extension section in the configuration file. Note that the leading . is dropped from extension.\nFor example to change the Python interpreter to C:\\Python39\\python.exe and add a Tcl/Tk interpreter, include the following in ~/.config/chezmoi/chezmoi.toml:\n[interpreters.py] command = \u0026#39;C:\\Python39\\python.exe\u0026#39; [interpreters.tcl] command = \u0026#34;tclsh\u0026#34; If the script in the source state is a template (with a .tmpl extension), then chezmoi will strip the .tmpl extension and use the next remaining extension to determine the interpreter to use.\n symlink mode #  By default, chezmoi will create regular files and directories. Setting mode = \u0026quot;symlink\u0026quot; will make chezmoi behave more like a dotfile manager that uses symlinks by default, i.e. chezmoi apply will make dotfiles symlinks to files in the source directory if the target is a regular file and is not encrypted, executable, private, or a template.\n Application order #  chezmoi is deterministic in its order of application. The order is:\n Read the source state. Read the destination state. Compute the target state. Run run_before_ scripts in alphabetical order. Update entries in the target state (files, directories, scripts, symlinks, etc.) in alphabetical order of their target name. Run run_after_ scripts in alphabetical order.  Target names are considered after all attributes are stripped. For example, given create_alpha and modify_dot_beta in the source state, .beta will be updated before alpha because .beta sorts before alpha.\nchezmoi assumes that the source or destination states are not modified while chezmoi is being executed. This assumption permits significant performance improvements, for example allowing chezmoi to only read files from the source and destination states if they are needed to compute the target state.\nchezmoi\u0026rsquo;s behavior when the above assumptions are violated is undefined. For example, using a run_before_ script to update files in the source or destination states violates the assumption that the source and destination states do not change while chezmoi is running.\n Special files and directories #  All files and directories in the source state whose name begins with . are ignored by default, unless they are one of the special files listed here. .chezmoidata.\u0026lt;format\u0026gt; and .chezmoitemplates are read before all other files so that they can be used in templates.\n .chezmoi.\u0026lt;format\u0026gt;.tmpl #  If a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl exists then chezmoi init will use it to create an initial config file. \u0026lt;format\u0026gt; must be one of the the supported config file formats, e.g. json, toml, or yaml.\n.chezmoi.\u0026lt;format\u0026gt;.tmpl examples #  {{ $email := promptString \u0026quot;email\u0026quot; -}} data: email: {{ $email | quote }}  .chezmoidata.\u0026lt;format\u0026gt; #  If a file called .chezmoidata.\u0026lt;format\u0026gt; exists in the source state, it is interpreted as a datasource available in most templates.\n.chezmoidata.\u0026lt;format\u0026gt; examples #  If .chezmoidata.toml contains the following (and no variable is overwritten in later stages):\neditor = \u0026#34;nvim\u0026#34; [directions] up = \u0026#34;k\u0026#34; down = \u0026#34;j\u0026#34; right = \u0026#34;l\u0026#34; left = \u0026#34;h\u0026#34; Then the following template:\nEDITOR={{ .editor }} MOVE_UP={{ .directions.up }} MOVE_DOWN={{ .directions.down }} MOVE_RIGHT={{ .directions.right }} MOVE_LEFT={{ .directions.left }} Will result in:\nEDITOR=nvim MOVE_UP=k MOVE_DOWN=j MOVE_RIGHT=l MOVE_LEFT=h  .chezmoiexternal.\u0026lt;format\u0026gt; #  If a file called .chezmoiexternal.\u0026lt;format\u0026gt; exists in the source state, it is interpreted as a list of external files and archives to be included as if they were in the source state.\n\u0026lt;format\u0026gt; must be one of chezmoi\u0026rsquo;s supported configuration file formats, e.g. json, toml, or yaml.\n.chezmoiexternal.\u0026lt;format\u0026gt; is interpreted as a template. This allows different externals to be included on different machines.\nEntries are indexed by target name relative to the directory of the .chezmoiexternal.\u0026lt;format\u0026gt; file, and must have a type and a url field. type can be either file or archive. If the entry\u0026rsquo;s parent directories do not already exist in the source state then chezmoi will create them as regular directories.\nEntries may have the following fields:\n   Variable Type Default value Description     type string none External type (file or archive)   encrypted bool false Whether the external is encrypted   exact bool false Add exact_ attribute to directories in archive   executable bool false Add executable_ attribute to file   filter.command string none Command to filter contents   filter.args []string none Extra args to command to filter contents   format string autodetect Format of archive   refreshPeriod duration 0 Refresh period   stripComponents int 0 Number of leading directory components to strip from archives   url string none URL    The optional boolean encrypted field specifies whether the file or archive is encrypted.\nIf optional string filter.command and array of strings filter.args are specified, the the file or archive is filtered by piping it into the command\u0026rsquo;s standard input and reading the command\u0026rsquo;s standard output.\nIf type is file then the target is a file with the contents of url. The optional boolean field executable may be set, in which case the target file will be executable.\nIf type is archive then the target is a directory with the contents of the archive at url. The optional boolean field exact may be set, in which case the directory and all subdirectories will be treated as exact directories, i.e. chezmoi apply will remove entries not present in the archive. The optional integer field stripComponents will remove leading path components from the members of archive. The optional string field format sets the archive format. The supported archive formats are tar, tar.gz, tgz, tar.bz2, tbz2, and zip. If format is not specified then chezmoi will guess the format using firstly the path of the URL and secondly its contents.\nBy default, chezmoi will cache downloaded URLs. The optional duration refreshPeriod field specifies how often chezmoi will re-download the URL. The default is zero meaning that chezmoi will never re-download unless forced. To force chezmoi to re-download URLs, pass the -R/--refresh-externals flag. Suitable refresh periods include one day (24h), one week (168h), or four weeks (672h).\n.chezmoiexternal.\u0026lt;format\u0026gt; examples #  [\u0026#34;.vim/autoload/plug.vim\u0026#34;] type = \u0026#34;file\u0026#34; url = \u0026#34;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#34; refreshPeriod = \u0026#34;168h\u0026#34; [\u0026#34;.oh-my-zsh\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/ohmyzsh/ohmyzsh/archive/master.tar.gz\u0026#34; exact = true stripComponents = 1 refreshPeriod = \u0026#34;168h\u0026#34; [\u0026#34;.oh-my-zsh/custom/plugins/zsh-syntax-highlighting\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/zsh-users/zsh-syntax-highlighting/archive/master.tar.gz\u0026#34; exact = true stripComponents = 1 refreshPeriod = \u0026#34;168h\u0026#34; [\u0026#34;.oh-my-zsh/custom/themes/powerlevel10k\u0026#34;] type = \u0026#34;archive\u0026#34; url = \u0026#34;https://github.com/romkatv/powerlevel10k/archive/v1.15.0.tar.gz\u0026#34; exact = true stripComponents = 1  .chezmoiignore #  If a file called .chezmoiignore exists in the source state then it is interpreted as a set of patterns to ignore. Patterns are matched using doublestar.Match and match against the target path, not the source path.\nPatterns can be excluded by prefixing them with a ! character. All excludes take priority over all includes.\nComments are introduced with the # character and run until the end of the line.\n.chezmoiignore is interpreted as a template. This allows different files to be ignored on different machines.\n.chezmoiignore files in subdirectories apply only to that subdirectory.\n.chezmoiignore examples #  README.md *.txt # ignore *.txt in the target directory */*.txt # ignore *.txt in subdirectories of the target directory # but not in subdirectories of subdirectories; # so a/b/c.txt would *not* be ignored backups/ # ignore backups folder in chezmoi directory and all its contents backups/** # ignore all contents of backups folder in chezmoi directory # but not backups folder itself {{- if ne .email \u0026quot;firstname.lastname@company.com\u0026quot; }} # Ignore .company-directory unless configured with a company email .company-directory # note that the pattern is not dot_company-directory {{- end }} {{- if ne .email \u0026quot;me@home.org }} .personal-file {{- end }}  .chezmoiremove #  If a file called .chezmoiremove exists in the source state then it is interpreted as a list of targets to remove. .chezmoiremove is interpreted as a template.\n .chezmoiroot #  If a file called .chezmoiroot exists in the root of the source directory then the source state is read from the directory specified in .chezmoiroot interpreted as a relative path to the source directory. .chezmoiroot is read before all other files in the source directory.\n .chezmoitemplates #  If a directory called .chezmoitemplates exists, then all files in this directory are parsed as templates are available as templates with a name equal to the relative path to the .chezmoitemplates directory.\nThe template action can be used to include these templates in another template. The value of . must be set explicitly if needed, otherwise the template will be executed with nil data.\n.chezmoitemplates examples #  Given:\n.chezmoitemplates/foo:\n{{ if true }}bar{{ end }} dot_config.tmpl:\n{{ template \u0026quot;foo\u0026quot; . }} The target state of .config will be bar.\n .chezmoiversion #  If a file called .chezmoiversion exists, then its contents are interpreted as a semantic version defining the minimum version of chezmoi required to interpret the source state correctly. chezmoi will refuse to interpret the source state if the current version is too old.\n.chezmoiversion examples #  1.5.0  Commands #   add target\u0026hellip; #  Add targets to the source state. If any target is already in the source state, then its source state is replaced with its current state in the destination directory.\n--autotemplate #  Automatically generate a template by replacing strings with variable names from the data section of the config file. Longer substitutions occur before shorter ones. This implies the --template option.\n-e, --empty #  Set the empty attribute on added files.\n-f, --force #  Add targets, even if doing so would cause a source template to be overwritten.\n--follow #  If the last part of a target is a symlink, add the target of the symlink instead of the symlink itself.\n--exact #  Set the exact attribute on added directories.\n-i, --include types #  Only add entries of type types.\n-p, --prompt #  Interactively prompt before adding each file.\n-r, --recursive #  Recursively add all files, directories, and symlinks.\n-T, --template #  Set the template attribute on added files and symlinks.\n--template-symlinks #  When adding symlink to an absolute path in the source directory or destination directory, create a symlink template with .chezmoi.sourceDir or .chezmoi.homeDir. This is useful for creating portable absolute symlinks.\nadd examples #  $ chezmoi add ~/.bashrc $ chezmoi add ~/.gitconfig --template $ chezmoi add ~/.vim --recursive $ chezmoi add ~/.oh-my-zsh --exact --recursive  apply [target\u0026hellip;] #  Ensure that target\u0026hellip; are in the target state, updating them if necessary. If no targets are specified, the state of all targets are ensured. If a target has been modified since chezmoi last wrote it then the user will be prompted if they want to overwrite the file.\n-i, --include types #  Only add entries of type types.\n--source-path #  Specify targets by source path, rather than target path. This is useful for applying changes after editing.\napply examples #  $ chezmoi apply $ chezmoi apply --dry-run --verbose $ chezmoi apply ~/.bashrc  archive #  Generate an archive of the target state. This can be piped into tar to inspect the target state.\n-f, --format tar|tar.gz|tgz|zip #  Write the archive in format. If --output is set the format is guessed from the extension, otherwise the default is tar.\n-i, --include types #  Only include entries of type types.\n-z, --gzip #  Compress the archive with gzip. This is automatically set if the format is tar.gz or tgz and is ignored if the format is zip.\narchive examples #  $ chezmoi archive | tar tvf - $ chezmoi archive --output=dotfiles.tar.gz $ chezmoi archive --output=dotfiles.zip  cat target\u0026hellip; #  Write the target contents of targets to stdout. targets must be files, scripts, or symlinks. For files, the target file contents are written. For scripts, the script\u0026rsquo;s contents are written. For symlinks, the target target is written.\ncat examples #  $ chezmoi cat ~/.bashrc  cd #  Launch a shell in the working tree (typically the source directory). chezmoi will launch the command set by the cd.command configuration variable with any extra arguments specified by cd.args. If this is not set, chezmoi will attempt to detect your shell and will finally fall back to an OS-specific default.\ncd examples #  $ chezmoi cd  chattr modifier target\u0026hellip; #  Change the attributes and/or type of targets. modifier specifies what to modify.\nAdd attributes by specifying them or their abbreviations directly, optionally prefixed with a plus sign (+). Remove attributes by prefixing them or their attributes with the string no or a minus sign (-). The available attribute modifiers and their abbreviations are:\n   Attribute modifier Abbreviation     after a   before b   empty e   encrypted none   exact none   executable x   once o   private p   readonly r   template t    The type of a target can be changed using a type modifier:\n   Type modifier     create   modify   script   symlink    The negative form of type modifiers, e.g. nocreate, changes the target to be a regular file if it is of that type, otherwise the type is left unchanged.\nMultiple modifications may be specified by separating them with a comma (,). If you use the -modifier form then you must put modifier after a -- to prevent chezmoi from interpreting -modifier as an option.\nchattr examples #  $ chezmoi chattr template ~/.bashrc $ chezmoi chattr noempty ~/.profile $ chezmoi chattr private,template ~/.netrc $ chezmoi chattr -- -x ~/.zshrc $ chezmoi chattr +create,+private ~/.kube/config  completion shell #  Generate shell completion code for the specified shell (bash, fish, powershell, or zsh).\ncompletion examples #  $ chezmoi completion bash $ chezmoi completion fish --output=~/.config/fish/completions/chezmoi.fish  data #  Write the computed template data to stdout.\n-f, --format json|yaml #  Set the output format.\ndata examples #  $ chezmoi data $ chezmoi data --format=yaml  decrypt [file\u0026hellip;] #  Decrypt files using chezmoi\u0026rsquo;s configured encryption. If no files are given, decrypt the standard input. The decrypted result is written to the standard output or a file if the --output flag is set.\n diff [target\u0026hellip;] #  Print the difference between the target state and the destination state for targets. If no targets are specified, print the differences for all targets.\nIf a diff.pager command is set in the configuration file then the output will be piped into it.\nIf diff.command is set then it will be invoked to show individual file differences with diff.args passed as arguments. Each element of diff.args is interpreted as a template with the variables .Destination and .Target available corresponding to the path of the file in the source and target state respectively. The default value of diff.args is [\u0026quot;{{ .Destination }}\u0026quot;, \u0026quot;{{ .Target }}\u0026quot;]. If diff.args does not contain any template arguments then {{ .Destination }} and {{ .Target }} will be appended automatically.\n--reverse #  Reverse the direction of the diff, i.e. show the changes to the target required to match the destination.\n--pager pager #  Pager to use for output.\n--use-builtin-diff #  Use chezmoi\u0026rsquo;s builtin diff, even if the diff.command configuration variable is set.\ndiff examples #  $ chezmoi diff $ chezmoi diff ~/.bashrc  docs [regexp] #  Print the documentation page matching the regular expression regexp. Matching is case insensitive. If no pattern is given, print REFERENCE.md.\n--pager pager #  Pager to use for output.\ndocs examples #  $ chezmoi docs $ chezmoi docs faq $ chezmoi docs howto  doctor #  Check for potential problems.\ndoctor examples #  $ chezmoi doctor  dump [target\u0026hellip;] #  Dump the target state of targets. If no targets are specified, then the entire target state.\n-f, --format json|yaml #  Set the output format.\n-i, --include types #  Only include entries of type types.\ndump examples #  $ chezmoi dump ~/.bashrc $ chezmoi dump --format=yaml  edit [target\u0026hellip;] #  Edit the source state of targets, which must be files or symlinks. If no targets are given then the working tree of the source directory is opened.\nThe editor used is the first non-empty string of the edit.command configuration variable, the $VISUAL environment variable, the $EDITOR environment variable. If none are set then chezmoi falls back to notepad.exe on Windows systems and vi on non-Windows systems.\nWhen the edit.command configuration variable is used, extra arguments can be passed to the editor with the editor.args configuration variable.\nEncrypted files are decrypted to a private temporary directory and the editor is invoked with the decrypted file. When the editor exits the edited decrypted file is re-encrypted and replaces the original file in the source state.\nIf the operating system supports hard links, then the edit command invokes the editor with filenames which match the target filename.\nchezmoi will emit a warning if the editor returns in less than edit.minDuration (default 1s). To disable this warning, set edit.minDuration to 0.\n-a, --apply #  Apply target immediately after editing. Ignored if there are no targets.\nedit examples #  $ chezmoi edit ~/.bashrc $ chezmoi edit ~/.bashrc --apply $ chezmoi edit  edit-config #  Edit the configuration file.\nedit-config examples #  $ chezmoi edit-config  encrypt [file\u0026hellip;] #  Encrypt files using chezmoi\u0026rsquo;s configured encryption. If no files are given, encrypt the standard input. The encrypted result is written to the standard output or a file if the --output flag is set.\n execute-template [template\u0026hellip;] #  Execute templates. This is useful for testing templates or for calling chezmoi from other scripts. templates are interpreted as literal templates, with no whitespace added to the output between arguments. If no templates are specified, the template is read from stdin.\n--init, -i #  Include simulated functions only available during chezmoi init.\n--promptBool pairs #  Simulate the promptBool function with a function that returns values from pairs. pairs is a comma-separated list of prompt=value pairs. If promptBool is called with a prompt that does not match any of pairs, then it returns false.\n--promptInt pairs #  Simulate the promptInt function with a function that returns values from pairs. pairs is a comma-separated list of prompt=value pairs. If promptInt is called with a prompt that does not match any of pairs, then it returns zero.\n--promptString, -p pairs #  Simulate the promptString function with a function that returns values from pairs. pairs is a comma-separated list of prompt=value pairs. If promptString is called with a prompt that does not match any of pairs, then it returns prompt unchanged.\n--stdinisatty bool #  Simulate the stdinIsATTY function by returning bool.\nexecute-template examples #  $ chezmoi execute-template \u0026#39;{{ .chezmoi.sourceDir }}\u0026#39; $ chezmoi execute-template \u0026#39;{{ .chezmoi.os }}\u0026#39; / \u0026#39;{{ .chezmoi.arch }}\u0026#39; $ echo \u0026#39;{{ .chezmoi | toJson }}\u0026#39; | chezmoi execute-template $ chezmoi execute-template --init --promptString email=me@home.org \u0026lt; ~/.local/share/chezmoi/.chezmoi.toml.tmpl  forget targets #  Remove targets from the source state, i.e. stop managing them.\nforget examples #  $ chezmoi forget ~/.bashrc  git [arg\u0026hellip;] #  Run git args in the working tree (typically the source directory). Note that flags in arguments must occur after -- to prevent chezmoi from interpreting them.\ngit examples #  $ chezmoi git add . $ chezmoi git add dot_gitconfig $ chezmoi git -- commit -m \u0026#34;Add .gitconfig\u0026#34;  help [command\u0026hellip;] #  Print the help associated with command, or general help if no command is given.\n init [repo] #  Setup the source directory, generate the config file, and optionally update the destination directory to match the target state. repo is expanded to a full git repo URL, using HTTPS by default, or SSH if the --ssh option is specified, according to the following patterns:\n   Pattern HTTPS Repo SSH repo     user https://github.com/user/dotfiles.git git@github.com:user/dotfiles.git   user/repo https://github.com/user/repo.git git@github.com:user/repo.git   site/user/repo https://site/user/repo.git git@site:user/repo.git   ~sr.ht/user https://git.sr.ht/~user/dotfiles git@git.sr.ht:~user/dotfiles.git   ~sr.ht/user/repo https://git.sr.ht/~user/repo git@git.sr.ht:~/user/repo.git    First, if the source directory is not already contain a repository, then if repo is given it is checked out into the source directory, otherwise a new repository is initialized in the source directory.\nSecond, if a file called .chezmoi.\u0026lt;format\u0026gt;.tmpl exists, where \u0026lt;format\u0026gt; is one of the supported file formats (e.g. json, toml, or yaml) then a new configuration file is created using that file as a template.\nThen, if the --apply flag is passed, chezmoi apply is run.\nThen, if the --purge flag is passed, chezmoi will remove the source directory and its config directory.\nFinally, if the --purge-binary is passed, chezmoi will attempt to remove its own binary.\n--apply #  Run chezmoi apply after checking out the repo and creating the config file.\n--branch branch #  Check out branch instead of the default branch.\n--config-path path #  Write the generated config file to path instead of the default location.\n--data bool #  Include existing template data when creating the config file. This defaults to true. Set this to false to simulate creating the config file with no existing template data.\n--depth depth #  Clone the repo with depth depth.\n--one-shot #  --one-shot is the equivalent of --apply, --depth=1, --force, --purge, and --purge-binary. It attempts to install your dotfiles with chezmoi and then remove all traces of chezmoi from the system. This is useful for setting up temporary environments (e.g. Docker containers).\n--purge #  Remove the source and config directories after applying.\n--purge-binary #  Attempt to remove the chezmoi binary after applying.\n--ssh #  Guess an SSH repo URL instead of an HTTPS repo.\ninit examples #  $ chezmoi init user $ chezmoi init user --apply $ chezmoi init user --apply --purge $ chezmoi init user/dots $ chezmoi init gitlab.com/user  import filename #  Import the source state from an archive file in to a directory in the source state. This is primarily used to make subdirectories of your home directory exactly match the contents of a downloaded archive. You will generally always want to set the --destination, --exact, and --remove-destination flags.\nThe supported archive formats are tar, tar.gz, tgz, tar.bz2, tbz2, and zip.\n--destination directory #  Set the destination (in the source state) where the archive will be imported.\n--exact #  Set the exact attribute on all imported directories.\n-r, --remove-destination #  Remove destination (in the source state) before importing.\n--strip-components n #  Strip n leading components from paths.\nimport examples #  $ curl -s -L -o ${TMPDIR}/oh-my-zsh-master.tar.gz https://github.com/ohmyzsh/ohmyzsh/archive/master.tar.gz $ mkdir -p $(chezmoi source-path)/dot_oh-my-zsh $ chezmoi import --strip-components 1 --destination ~/.oh-my-zsh ${TMPDIR}/oh-my-zsh-master.tar.gz  manage targets #  manage is an alias for add for symmetry with unmanage.\n managed #  List all managed entries in the destination directory in alphabetical order.\n-i, --include types #  Only include entries of type types.\nmanaged examples #  $ chezmoi managed $ chezmoi managed --include=files $ chezmoi managed --include=files,symlinks $ chezmoi managed -i d $ chezmoi managed -i d,f  merge target\u0026hellip; #  Perform a three-way merge between the destination state, the target state, and the source state for each target. The merge tool is defined by the merge.command configuration variable, and defaults to vimdiff. If multiple targets are specified the merge tool is invoked separately and sequentially for each target. If the target state cannot be computed (for example if source is a template containing errors or an encrypted file that cannot be decrypted) a two-way merge is performed instead.\nThe order of arguments to merge.command is set by merge.args. Each argument is interpreted as a template with the variables .Destination, .Source, and .Target available corresponding to the path of the file in the destination state, the source state, and the target state respectively. The default value of merge.args is [\u0026quot;{{ .Destination }}\u0026quot;, \u0026quot;{{ .Source }}\u0026quot;, \u0026quot;{{ .Target }}\u0026quot;]. If merge.args does not contain any template arguments then {{ .Destination }}, {{ .Source }}, and {{ .Target }} will be appended automatically.\nmerge examples #  $ chezmoi merge ~/.bashrc  merge-all [target\u0026hellip;] #  Perform a three-way merge for file whose actual state does not match its target state. The merge is performed with chezmoi merge.\nmerge-all examples #  $ chezmoi merge-all  purge #  Remove chezmoi\u0026rsquo;s configuration, state, and source directory, but leave the target state intact.\n-f, --force #  Remove without prompting.\npurge examples #  $ chezmoi purge $ chezmoi purge --force  remove targets #  Remove targets from both the source state and the destination directory.\n-f, --force #  Remove without prompting.\n re-add #  Re-add all modified files in the target state. chezmoi will not overwrite templates, and all entries that are not files are ignored.\nre-add examples #  $ chezmoi re-add  rm targets #  rm is an alias for remove.\n secret #  Run a secret manager\u0026rsquo;s CLI, passing any extra arguments to the secret manager\u0026rsquo;s CLI. This is primarily for verifying chezmoi\u0026rsquo;s integration with your secret manager. Normally you would use template functions to retrieve secrets. Note that if you want to pass flags to the secret manager\u0026rsquo;s CLI you will need to separate them with -- to prevent chezmoi from interpreting them.\nTo get a full list of available commands run:\n$ chezmoi secret help secret examples #  $ chezmoi secret keyring set --service=service --user=user --value=password $ chezmoi secret keyring get --service=service --user=user  source-path [target\u0026hellip;] #  Print the path to each target\u0026rsquo;s source state. If no targets are specified then print the source directory.\nsource-path examples #  $ chezmoi source-path $ chezmoi source-path ~/.bashrc  state #  Manipulate the persistent state.\nstate examples #  $ chezmoi state data $ chezmoi state delete --bucket=bucket --key=key $ chezmoi state dump $ chezmoi state get --bucket=bucket --key=key $ chezmoi state set --bucket=bucket --key=key --value=value $ chezmoi state reset  status #  Print the status of the files and scripts managed by chezmoi in a format similar to git status.\nThe first column of output indicates the difference between the last state written by chezmoi and the actual state. The second column indicates the difference between the actual state and the target state.\n-i, --include types #  Only include entries of type types.\nstatus examples #  $ chezmoi status  unmanage target\u0026hellip; #  unmanage is an alias for forget for symmetry with manage.\n unmanaged #  List all unmanaged files in the destination directory.\nunmanaged examples #  $ chezmoi unmanaged  update #  Pull changes from the source repo and apply any changes.\n-i, --include types #  Only update entries of type types.\nupdate examples #  $ chezmoi update  upgrade #  Upgrade chezmoi by downloading and installing the latest released version. This will call the GitHub API to determine if there is a new version of chezmoi available, and if so, download and attempt to install it in the same way as chezmoi was previously installed.\nIf the any of the $CHEZMOI_GITHUB_ACCESS_TOKEN, $GITHUB_ACCESS_TOKEN, or $GITHUB_TOKEN environment variables are set, then the first value found will be used to authenticate requests to the GitHub API, otherwise unauthenticated requests are used which are subject to stricter rate limiting. Unauthenticated requests should be sufficient for most cases.\n verify [target\u0026hellip;] #  Verify that all targets match their target state. chezmoi exits with code 0 (success) if all targets match their target state, or 1 (failure) otherwise. If no targets are specified then all targets are checked.\n-i, --include types #  Only include entries of type types.\nverify examples #  $ chezmoi verify $ chezmoi verify ~/.bashrc  Editor configuration #  The edit and edit-config commands use the editor specified by the VISUAL environment variable, the $EDITOR environment variable, or vi, whichever is specified first.\n pinentry configuration #  By default, chezmoi will request passwords from the terminal.\nIf the --no-tty option is passed, then chezmoi will instead read passwords from the standard input.\nOtherwise, if the configuration variable pinentry.command is set then chezmoi will instead used the given command to read passwords, assuming that it follows the Assuan protocol like GnuPG\u0026rsquo;s pinentry. The configuration variable pinentry.args specifies extra arguments to be passed to pinentry.command and the configuration variable pinentry.options specifies extra options to be set. The default pinentry.options is [\u0026quot;allow-external-password-cache\u0026quot;].\nExample pinentry configuration #  [pinentry] command = \u0026#34;pinentry\u0026#34;  Umask configuration #  By default, chezmoi uses your current umask as set by your operating system and shell. chezmoi only stores crude permissions in its source state, namely in the executable and private attributes, corresponding to the umasks of 0o111 and 0o077 respectively.\nFor machine-specific control of umask, set the umask configuration variable in chezmoi\u0026rsquo;s configuration file, for example:\numask = 0o22  Template execution #  chezmoi executes templates using text/template. The result is treated differently depending on whether the target is a file or a symlink.\nIf target is a file, then:\n If the result is an empty string, then the file is removed. Otherwise, the target file contents are result.  If the target is a symlink, then:\n Leading and trailing whitespace are stripped from the result. If the result is an empty string, then the symlink is removed. Otherwise, the target symlink target is the result.  chezmoi executes templates using text/template\u0026rsquo;s missingkey=error option, which means that misspelled or missing keys will raise an error. This can be overridden by setting a list of options in the configuration file, for example:\n[template] options = [\u0026#34;missingkey=zero\u0026#34;] For a full list of options, see Template.Option.\n Template variables #  chezmoi provides the following automatically-populated variables:\n   Variable Type Value     .chezmoi.arch string Architecture, e.g. amd64, arm, etc. as returned by runtime.GOARCH.   .chezmoi.args []string The arguments passed to the chezmoi command, starting with the program command.   .chezmoi.executable string The path to the chezmoi executable, if available.   .chezmoi.fqdnHostname string The fully-qualified domain name hostname of the machine chezmoi is running on.   .chezmoi.group string The group of the user running chezmoi.   .chezmoi.homeDir string The home directory of the user running chezmoi.   .chezmoi.hostname string The hostname of the machine chezmoi is running on, up to the first ..   .chezmoi.kernel string Contains information from /proc/sys/kernel. Linux only, useful for detecting specific kernels (e.g. Microsoft\u0026rsquo;s WSL kernel).   .chezmoi.os string Operating system, e.g. darwin, linux, etc. as returned by runtime.GOOS.   .chezmoi.osRelease string The information from /etc/os-release, Linux only, run chezmoi data to see its output.   .chezmoi.sourceDir string The source directory.   .chezmoi.sourceFile string The path of the template relative to the source directory.   .chezmoi.username string The username of the user running chezmoi.   .chezmoi.version.builtBy string The program that built the chezmoi executable, if set.   .chezmoi.version.commit string The git commit at which the chezmoi executable was built, if set.   .chezmoi.version.date string The timestamp at which the chezmoi executable was built, if set.   .chezmoi.version.version string The version of chezmoi.    Additional variables can be defined in the config file in the data section. Variable names must consist of a letter and be followed by zero or more letters and/or digits.\n Template functions #  All standard text/template and text template functions from sprig are included. chezmoi provides some additional functions.\n bitwarden [arg\u0026hellip;] #  bitwarden returns structured data retrieved from Bitwarden using the Bitwarden CLI (bw). args are passed to bw get unchanged and the output from bw get is parsed as JSON. The output from bw get is cached so calling bitwarden multiple times with the same arguments will only invoke bw once.\nbitwarden examples #  username = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;\u0026lt;itemid\u0026gt;\u0026quot;).login.username }} password = {{ (bitwarden \u0026quot;item\u0026quot; \u0026quot;\u0026lt;itemid\u0026gt;\u0026quot;).login.password }}  bitwardenAttachment filename itemid #  bitwardenAttachment returns a document from Bitwarden using the Bitwarden CLI (bw). filename and itemid is passed to bw get attachment \u0026lt;filename\u0026gt; --itemid \u0026lt;itemid\u0026gt; and the output from bw is returned. The output from bw is cached so calling bitwardenAttachment multiple times with the same filename and itemid will only invoke bw once.\nbitwardenAttachment examples #  {{- (bitwardenAttachment \u0026quot;\u0026lt;filename\u0026gt;\u0026quot; \u0026quot;\u0026lt;itemid\u0026gt;\u0026quot;) -}}  bitwardenFields [arg\u0026hellip;] #  bitwardenFields returns structured data retrieved from Bitwarden using the Bitwarden CLI (bw). args are passed to bw get unchanged, the output from bw get is parsed as JSON, and elements of fields are returned as a map indexed by each field\u0026rsquo;s name. For example, given the output from bw get:\n{ \u0026#34;object\u0026#34;: \u0026#34;item\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;bf22e4b4-ae4a-4d1c-8c98-ac620004b628\u0026#34;, \u0026#34;organizationId\u0026#34;: null, \u0026#34;folderId\u0026#34;: null, \u0026#34;type\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;notes\u0026#34;: null, \u0026#34;favorite\u0026#34;: false, \u0026#34;fields\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;text-value\u0026#34;, \u0026#34;type\u0026#34;: 0 }, { \u0026#34;name\u0026#34;: \u0026#34;hidden\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hidden-value\u0026#34;, \u0026#34;type\u0026#34;: 1 } ], \u0026#34;login\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;username-value\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password-value\u0026#34;, \u0026#34;totp\u0026#34;: null, \u0026#34;passwordRevisionDate\u0026#34;: null }, \u0026#34;collectionIds\u0026#34;: [], \u0026#34;revisionDate\u0026#34;: \u0026#34;2020-10-28T00:21:02.690Z\u0026#34; } the return value will be the map\n{ \u0026#34;hidden\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;hidden\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;value\u0026#34;: \u0026#34;hidden-value\u0026#34; }, \u0026#34;token\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;token\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;value\u0026#34;: \u0026#34;token-value\u0026#34; } } The output from bw get is cached so calling bitwarden multiple times with the same arguments will only invoke bw get once.\nbitwardenFields examples #  {{ (bitwardenFields \u0026quot;item\u0026quot; \u0026quot;\u0026lt;itemid\u0026gt;\u0026quot;).token.value }}  decrypt ciphertext #  decrypt decrypts ciphertext using chezmoi\u0026rsquo;s configured encryption method.\ndecrypt examples #  {{ joinPath .chezmoi.sourceDir \u0026quot;.ignored-encrypted-file.age\u0026quot; | include | decrypt }}  encrypt plaintext #  encrypt encrypts plaintext using chezmoi\u0026rsquo;s configured encryption method.\n gitHubKeys user #  gitHubKeys returns user\u0026rsquo;s public SSH keys from GitHub using the GitHub API. The returned value is a slice of structs with .ID and .Key fields.\nWARNING if you use this function to populate your ~/.ssh/authorized_keys file then you potentially open SSH access to anyone who is able to modify or add to your GitHub public SSH keys, possibly including certain GitHub employees. You should not use this function on publicly-accessible machines and should always verify that no unwanted keys have been added, for example by using the -v / --verbose option when running chezmoi apply or chezmoi update.\nBy default, an anonymous GitHub API request will be made, which is subject to GitHub\u0026rsquo;s rate limits (currently 60 requests per hour per source IP address). If any of the environment variables $CHEZMOI_GITHUB_ACCESS_TOKEN, $GITHUB_ACCESS_TOKEN, or $GITHUB_TOKEN are found, then the first one found will be used to authenticate the GitHub API request, with a higher rate limit (currently 5,000 requests per hour per user).\nIn practice, GitHub API rate limits are high enough that you should rarely need to set a token, unless you are sharing a source IP address with many other GitHub users. If needed, the GitHub documentation describes how to create a personal access token.\ngitHubKeys examples #  {{ range (gitHubKeys \u0026quot;user\u0026quot;) }} {{- .Key }} {{ end }}  gitHubLatestRelease user-repo #  gitHubLatestRelease calls the GitHub API to retrieve the latest release about the given user-repo, returning structured data as defined by the GitHub Go API bindings.\nCalls to gitHubLatestRelease are cached so calling gitHubLatestRelease with the same user-repo will only result in one call to the GitHub API.\ngitHubLatestRelease uses the same API request mechanism as gitHubKeys.\ngitHubLatestRelease examples #  {{ (gitHubLatestRelease \u0026quot;docker/compose\u0026quot;).TagName }}  gopass gopass-name #  gopass returns passwords stored in gopass using the gopass CLI (gopass). gopass-name is passed to gopass show --password \u0026lt;gopass-name\u0026gt; and the first line of the output of gopass is returned with the trailing newline stripped. The output from gopass is cached so calling gopass multiple times with the same gopass-name will only invoke gopass once.\ngopass examples #  {{ gopass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  gopassRaw gopass-name #  gopass returns raw passwords stored in gopass using the gopass CLI (gopass). gopass-name is passed to gopass show --noparsing \u0026lt;gopass-name\u0026gt; and the output is returned. The output from gopassRaw is cached so calling gopassRaw multiple times with the same gopass-name will only invoke gopass once.\n include filename #  include returns the literal contents of the file named *filename*. Relative paths are interpreted relative to the source directory.\n ioreg #  On macOS, ioreg returns the structured output of the ioreg -a -l command, which includes detailed information about the I/O Kit registry.\nOn non-macOS operating systems, ioreg returns nil.\nThe output from ioreg is cached so multiple calls to the ioreg function will only execute the ioreg -a -l command once.\nioreg examples #  {{ if (eq .chezmoi.os \u0026quot;darwin\u0026quot;) }} {{ $serialNumber := index ioreg \u0026quot;IORegistryEntryChildren\u0026quot; 0 \u0026quot;IOPlatformSerialNumber\u0026quot; }} {{ end }}  joinPath element\u0026hellip; #  joinPath joins any number of path elements into a single path, separating them with the OS-specific path separator. Empty elements are ignored. The result is cleaned. If the argument list is empty or all its elements are empty, joinPath returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.\njoinPath examples #  {{ joinPath .chezmoi.homeDir \u0026quot;.zshrc\u0026quot; }}  keepassxc entry #  keepassxc returns structured data retrieved from a KeePassXC database using the KeePassXC CLI (keepassxc-cli). The database is configured by setting keepassxc.database in the configuration file. database and entry are passed to keepassxc-cli show. You will be prompted for the database password the first time keepassxc-cli is run, and the password is cached, in plain text, in memory until chezmoi terminates. The output from keepassxc-cli is parsed into key-value pairs and cached so calling keepassxc multiple times with the same entry will only invoke keepassxc-cli once.\nkeepassxc examples #  username = {{ (keepassxc \u0026quot;example.com\u0026quot;).UserName }} password = {{ (keepassxc \u0026quot;example.com\u0026quot;).Password }}  keepassxcAttribute entry attribute #  keepassxcAttribute returns the attribute attribute of entry using keepassxc-cli, with any leading or trailing whitespace removed. It behaves identically to the keepassxc function in terms of configuration, password prompting, password storage, and result caching.\nkeepassxcAttribute examples #  {{ keepassxcAttribute \u0026quot;SSH Key\u0026quot; \u0026quot;private-key\u0026quot; }}  keyring service user #  keyring retrieves the value associated with service and user from the user\u0026rsquo;s keyring.\n   OS Keyring     macOS Keychain   Linux GNOME Keyring   Windows Windows Credentials Manager    keyring examples #  [github] user = {{ .github.user | quote }} token = {{ keyring \u0026quot;github\u0026quot; .github.user | quote }}  lastpass id #  lastpass returns structured data from LastPass using the LastPass CLI (lpass). id is passed to lpass show --json \u0026lt;id\u0026gt; and the output from lpass is parsed as JSON. In addition, the note field, if present, is further parsed as colon-separated key-value pairs. The structured data is an array so typically the index function is used to extract the first item. The output from lastpass is cached so calling lastpass multiple times with the same id will only invoke lpass once.\nlastpass examples #  githubPassword = {{ (index (lastpass \u0026quot;GitHub\u0026quot;) 0).password | quote }} {{ (index (lastpass \u0026quot;SSH\u0026quot;) 0).note.privateKey }}  lastpassRaw id #  lastpassRaw returns structured data from LastPass using the LastPass CLI (lpass). It behaves identically to the lastpass function, except that no further parsing is done on the note field.\nlastpassRaw examples #  {{ (index (lastpassRaw \u0026quot;SSH Private Key\u0026quot;) 0).note }}  lookPath file #  lookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory. If file is not found, lookPath returns an empty string.\nlookPath is not hermetic: its return value depends on the state of the environment and the filesystem at the moment the template is executed. Exercise caution when using it in your templates.\nlookPath examples #  {{ if lookPath \u0026quot;diff-so-fancy\u0026quot; }} # diff-so-fancy is in $PATH {{ end }}  mozillaInstallHash path #  mozillaInstallHash returns the Mozilla install hash for path. This is a convenience function to assist the management of Firefox profiles.\n onepassword uuid [vault-uuid [account-name]] #  onepassword returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt; and the output from op is parsed as JSON. The output from op is cached so calling onepassword multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance. If the optional account-name is supplied, it will be passed along to the op get call, which will help it look in the right account, in case you have multiple accounts (eg. personal and work accounts).\nonepassword examples #  {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).details.password }} {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot;).details.password }} {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot;).details.password }} {{ (onepassword \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot;).details.password }}  onepasswordDocument uuid [vault-uuid [account-name]] #  onepassword returns a document from 1Password using the 1Password CLI (op). uuid is passed to op get document \u0026lt;uuid\u0026gt; and the output from op is returned. The output from op is cached so calling onepasswordDocument multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance. If the optional account-name is supplied, it will be passed along to the op get call, which will help it look in the right account, in case you have multiple accounts (eg. personal and work accounts).\nonepasswordDocument examples #  {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; -}} {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot; -}} {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot; -}} {{- onepasswordDocument \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot; -}}  onepasswordDetailsFields uuid [vault-uuid [account-name]] #  onepasswordDetailsFields returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt;, the output from op is parsed as JSON, and elements of details.fields are returned as a map indexed by each field\u0026rsquo;s designation. For example, give the output from op:\n{ \u0026#34;uuid\u0026#34;: \u0026#34;\u0026lt;uuid\u0026gt;\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;fields\u0026#34;: [ { \u0026#34;designation\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;exampleuser\u0026#34; }, { \u0026#34;designation\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;examplepassword\u0026#34; } ] } } the return value will be the map:\n{ \u0026#34;username\u0026#34;: { \u0026#34;designation\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;exampleuser\u0026#34; }, \u0026#34;password\u0026#34;: { \u0026#34;designation\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;examplepassword\u0026#34; } } The output from op is cached so calling onepasswordDetailsFields multiple times with the same uuid will only invoke op once. If the optional vault-uuid is supplied, it will be passed along to the op get call, which can significantly improve performance. If the optional account-name is supplied, it will be passed along to the op get call, which will help it look in the right account, in case you have multiple accounts (eg. personal and work accounts).\nonepasswordDetailsFields examples #  {{ (onepasswordDetailsFields \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot;).password.value }} {{ (onepasswordDetailsFields \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot;).password.value }} {{ (onepasswordDetailsFields \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;vault-uuid\u0026gt;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot;).password.value }} {{ (onepasswordDetailsFields \u0026quot;\u0026lt;uuid\u0026gt;\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026lt;account-name\u0026gt;\u0026quot;).password.value }}  onepasswordItemFields uuid [vault-uuid [account-name]] #  onepasswordItemFields returns structured data from 1Password using the 1Password CLI (op). uuid is passed to op get item \u0026lt;uuid\u0026gt;, the output from op is parsed as JSON, and each element of details.sections are iterated over and any fields are returned as a map indexed by each field\u0026rsquo;s n. For example, give the output from op:\n{ \u0026#34;uuid\u0026#34;: \u0026#34;\u0026lt;uuid\u0026gt;\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;sections\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;linked items\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Related Items\u0026#34; }, { \u0026#34;fields\u0026#34;: [ { \u0026#34;k\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;D4328E0846D2461E8E455D7A07B93397\u0026#34;, \u0026#34;t\u0026#34;: \u0026#34;exampleLabel\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;exampleValue\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;Section_20E0BD380789477D8904F830BFE8A121\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\u0026#34; } ] }, } the return value will be the map:\n{ \u0026#34;exampleLabel\u0026#34;: { \u0026#34;k\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;D4328E0846D2461E8E455D7A07B93397\u0026#34;, \u0026#34;t\u0026#34;: \u0026#34;exampleLabel\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;exampleValue\u0026#34; } } The result of\n{{ (onepasswordItemFields \u0026quot;abcdefghijklmnopqrstuvwxyz\u0026quot;).exampleLabel.v }} is equivalent to calling\n$ op get item abcdefghijklmnopqrstuvwxyz --fields exampleLabel  output name [arg\u0026hellip;] #  output returns the output of executing the command name with args. If executing the command returns an error then template execution exits with an error. The execution occurs every time that the template is executed. It is the user\u0026rsquo;s responsibility to ensure that executing the command is both idempotent and fast.\noutput examples #  current-context: {{ output \u0026quot;kubectl\u0026quot; \u0026quot;config\u0026quot; \u0026quot;current-context\u0026quot; | trim }}  pass pass-name #  pass returns passwords stored in pass using the pass CLI (pass). pass-name is passed to pass show \u0026lt;pass-name\u0026gt; and the first line of the output of pass is returned with the trailing newline stripped. The output from pass is cached so calling pass multiple times with the same pass-name will only invoke pass once.\npass examples #  {{ pass \u0026quot;\u0026lt;pass-name\u0026gt;\u0026quot; }}  passRaw pass-name #  passRaw returns passwords stored in pass using the pass CLI (pass). pass-name is passed to pass show \u0026lt;pass-name\u0026gt; and the output is returned. The output from pass is cached so calling passRaw multiple times with the same pass-name will only invoke pass once.\n promptBool prompt [default] #  promptBool prompts the user with prompt and returns the user\u0026rsquo;s response interpreted as a boolean. If default is passed the user\u0026rsquo;s response is empty then it returns default. It is only available when generating the initial config file. The user\u0026rsquo;s response is interpreted as follows (case insensitive):\n   Response Result     1, on, t, true, y, yes true   0, off, f, false, n, no false     promptInt prompt [default] #  promptInt prompts the user with prompt and returns the user\u0026rsquo;s response interpreted as an integer. If default is passed and the user\u0026rsquo;s response is empty then it returns default. It is only available when generating the initial config file.\n promptString prompt [default] #  promptString prompts the user with prompt and returns the user\u0026rsquo;s response with all leading and trailing spaces stripped. If default is passed and the user\u0026rsquo;s response is empty then it returns default. It is only available when generating the initial config file.\npromptString examples #  {{ $email := promptString \u0026quot;email\u0026quot; -}} [data] email = {{ $email | quote }}  secret [arg\u0026hellip;] #  secret returns the output of the generic secret command defined by the secret.command configuration variable with args with leading and trailing whitespace removed. The output is cached so multiple calls to secret with the same args will only invoke the generic secret command once.\n secretJSON [arg\u0026hellip;] #  secretJSON returns structured data from the generic secret command defined by the secret.command configuration variable with args. The output is parsed as JSON. The output is cached so multiple calls to secret with the same args will only invoke the generic secret command once.\n stat name #  stat runs stat(2) on name. If name exists it returns structured data. If name does not exist then it returns a false value. If stat(2) returns any other error then it raises an error. The structured value returned if name exists contains the fields name, size, mode, perm, modTime, and isDir.\nstat is not hermetic: its return value depends on the state of the filesystem at the moment the template is executed. Exercise caution when using it in your templates.\nstat examples #  {{ if stat (joinPath .chezmoi.homeDir \u0026quot;.pyenv\u0026quot;) }} # ~/.pyenv exists {{ end }}  stdinIsATTY #  stdinIsATTY returns true if chezmoi\u0026rsquo;s standard input is a TTY. It is only available when generating the initial config file. It is primarily useful for determining whether prompt* functions should be called or default values be used.\nstdinIsATTY examples #  {{ $email := \u0026quot;\u0026quot; }} {{ if stdinIsATTY }} {{ $email = promptString \u0026quot;email\u0026quot; }} {{ else }} {{ $email = \u0026quot;user@example.com\u0026quot; }} {{ end }}  vault key #  vault returns structured data from Vault using the Vault CLI (vault). key is passed to vault kv get -format=json \u0026lt;key\u0026gt; and the output from vault is parsed as JSON. The output from vault is cached so calling vault multiple times with the same key will only invoke vault once.\nvault examples #  {{ (vault \u0026quot;\u0026lt;key\u0026gt;\u0026quot;).data.data.password }}  writeToStdout string\u0026hellip; #  writeToStdout writes each string to stdout. It is only available when generating the initial config file.\nwriteToStdout examples #  {{- writeToStdout \u0026quot;Hello, world\\n\u0026quot; -}} "},{"id":10,"href":"/docs/related/","title":"Related","section":"Docs","content":"Related Software #   github.com/alker0/chezmoi.vim #  Intelligent VIM syntax highlighting when editing files in your source directory. Works with both chezmoi edit and editing files directly.\n github.com/hussainweb/ansible-role-chezmoi #  Installs chezmoi on Ubuntu and Debian servers.\n github.com/tcaxle/drapeau #  An add-on to synchronise your colorschemes across systems and allow easy colorscheme switching using chezmoi templates.\n github.com/tuh8888/chezmoi.el #  Convenience functions for interacting with chezmoi in Emacs.\n github.com/Lilja/vim-chezmoi #  A plugin for VIM to apply the dotfile you are editing on :w.\n "},{"id":11,"href":"/docs/security/","title":"Security","section":"Docs","content":"Security #   Supported versions #  Only the most recent version of chezmoi is supported with security updates.\n Reporting a vulnerability #  Please report vulnerabilities by opening a GitHub issue or sending an email to twpayne+chezmoi-security@gmail.com.\n "},{"id":12,"href":"/docs/templating/","title":"Templating","section":"Docs","content":"Templating Guide #   Introduction #  Templates are used to change the contents of a file depending on the environment. For example, you can use the hostname of the machine to create different configurations on different machines.\nchezmoi uses the text/template syntax from Go extended with text template functions from sprig.\nWhen reading files from the source state, chezmoi interprets them as a template if either of the following is true:\n The file name has a .tmpl suffix. The file is in the .chezmoitemplates directory, or a subdirectory of .chezmoitemplates.   Template data #  chezmoi provides a variety of template variables. For a full list, run\n$ chezmoi data These come from a variety of sources (later data overwrite earlier ones):\n Variables populated by chezmoi are in .chezmoi, for example .chezmoi.os. Variables created by you in the .chezmoidata.\u0026lt;format\u0026gt; configuration file. The various supported formats (json, toml and yaml) are read in alphabetical order. Variables created by you in the data section of the configuration file.  Furthermore, chezmoi provides a variety of functions to retrieve data at runtime from password managers, environment variables, and the filesystem.\n Creating a template file #  There are several ways to create a template:\n When adding a file for the first time, pass the --template argument, for example:  $ chezmoi add --template ~/.zshrc  When adding a file for the first time, you can pass the --autotemplate argument, which tells chezmoi to make the file as a template and automatically replace variables that chezmoi knows about, for example:  $ chezmoi add --autotemplate ~/.zshrc  If a file is already managed by chezmoi, but is not a template, you can make it a template by running, for example:  $ chezmoi chattr +template ~/.zshrc  You can create a template manually in the source directory by giving it a .tmpl extension, for example:  $ chezmoi cd $ $EDITOR dot_zshrc.tmpl   Templates in .chezmoitemplates must be created manually, for example:\nchezmoi cd mkdir -p .chezmoitemplates cd .chezmoitemplates $EDITOR mytemplate     Editing a template file #  The easiest way to edit a template is to use chezmoi edit, for example:\n$ chezmoi edit ~/.zshrc This will open the source file for ~/.zshrc in $EDITOR. When you quit the editor, chezmoi will check the template syntax.\nIf you want the changes you make to be immediately applied after you quit the editor, use the --apply option, for example:\n$ chezmoi edit --apply ~/.zshrc  Testing templates #  Templates can be tested with the chezmoi execute-template command which treats each of its arguments as a template and executes it. This can be useful for testing small fragments of templates, for example:\n$ chezmoi execute-template \u0026#39;{{ .chezmoi.hostname }}\u0026#39; If there are no arguments, chezmoi execute-template will read the template from the standard input. This can be useful for testing whole files, for example:\n$ chezmoi cd $ chezmoi execute-template \u0026lt; dot_zshrc.tmpl  Template syntax #  Template actions are written inside double curly brackets, {{ and }}. Actions can be variables, pipelines, or control statements. Text outside actions is copied literally.\nVariables are written literally, for example:\n{{ .chezmoi.hostname }} Conditional expressions can be written using if, else if, else, and end, for example:\n{{ if (eq .chezmoi.os \u0026quot;darwin\u0026quot;) }} # darwin {{ else if (eq .chezmoi.os \u0026quot;linux\u0026quot; ) }} # linux {{ else }} # other operating system {{ end }} For a full description of the template syntax, see the text/template documentation.\n Removing whitespace #  For formatting reasons you might want to leave some whitespace after or before the template code. This whitespace will remain in the final file, which you might not want.\nA solution for this is to place a minus sign and a space next to the brackets. So {{-  for the left brackets and  -}} for the right brackets. Here\u0026rsquo;s an example:\nHOSTNAME={{- .chezmoi.hostname }} This will result in\nHOSTNAME=myhostname Notice that this will remove any number of tabs, spaces and even newlines and carriage returns.\n Debugging templates #  If there is a mistake in one of your templates and you want to debug it, chezmoi can help you. You can use this subcommand to test and play with the examples in these docs as well.\nThere is a very handy subcommand called execute-template. chezmoi will interpret any data coming from stdin or at the end of the command. It will then interpret all templates and output the result to stdout. For example with the command:\n$ chezmoi execute-template \u0026#39;{{ .chezmoi.os }}/{{ .chezmoi.arch }}\u0026#39; chezmoi will output the current OS and architecture to stdout.\nYou can also feed the contents of a file to this command by typing:\n$ cat foo.txt | chezmoi execute-template  Simple logic #  A very useful feature of chezmoi templates is the ability to perform logical operations.\n# common config export EDITOR=vi # machine-specific configuration {{- if eq .chezmoi.hostname \u0026quot;work-laptop\u0026quot; }} # this will only be included in ~/.bashrc on work-laptop {{- end }} In this example chezmoi will look at the hostname of the machine and if that is equal to \u0026ldquo;work-laptop\u0026rdquo;, the text between the if and the end will be included in the result.\n Boolean functions #     Function Return value     eq Returns true if the first argument is equal to any of the other arguments.   not Returns the boolean negation of its single argument.   and Returns the boolean AND of its arguments by returning the first empty argument or the last argument, that is, and x y behaves as if x then y else x. All the arguments are evaluated.   or Returns the boolean OR of its arguments by returning the first non-empty argument or the last argument, that is, or x y behaves as if x then x else y All the arguments are evaluated.     Integer functions #     Function Return value     len Returns the integer length of its argument.   eq Returns the boolean truth of arg1 == arg2.   ne Returns the boolean truth of arg1 != arg2.   lt Returns the boolean truth of arg1 \u0026lt; arg2.   le Returns the boolean truth of arg1 \u0026lt;= arg2.   gt Returns the boolean truth of arg1 \u0026gt; arg2.   ge Returns the boolean truth of arg1 \u0026gt;= arg2.     More complicated logic #  Up until now, we have only seen if statements that can handle at most two variables. In this part we will see how to create more complicated expressions.\nYou can also create more complicated expressions. The eq command can accept multiple arguments. It will check if the first argument is equal to any of the other arguments.\n{{ if eq \u0026quot;foo\u0026quot; \u0026quot;foo\u0026quot; \u0026quot;bar\u0026quot; }}hello{{end}} {{ if eq \u0026quot;foo\u0026quot; \u0026quot;bar\u0026quot; \u0026quot;foo\u0026quot; }}hello{{end}} {{ if eq \u0026quot;foo\u0026quot; \u0026quot;bar\u0026quot; \u0026quot;bar\u0026quot; }}hello{{end}} The first two examples will output hello and the last example will output nothing.\nThe operators or and and can also accept multiple arguments.\n Chaining operators #  You can perform multiple checks in one if statement.\n{{ if (and (eq .chezmoi.os \u0026quot;linux\u0026quot;) (ne .email \u0026quot;me@home.org\u0026quot;)) }} ... {{ end }} This will check if the operating system is Linux and the configured email is not the home email. The brackets are needed here, because otherwise all the arguments will be give to the and command.\nThis way you can chain as many operators together as you like.\n Helper functions #  chezmoi has added multiple helper functions to the text/template syntax.\nchezmoi includes sprig, an extension to the text/template format that contains many helper functions. Take a look at their documentation for a list.\nchezmoi adds a few functions of its own as well. Take a look at the reference for complete list.\n Template variables #  chezmoi defines a few useful templates variables that depend on the system you are currently on. A list of the variables defined by chezmoi can be found here.\nThere are, however more variables than that. To view the variables available on your system, execute:\n$ chezmoi data This outputs the variables in JSON format by default. To access the variable chezmoi.kernel.osrelease in a template, use\n{{ .chezmoi.kernel.osrelease }} This way you can also access the variables you defined yourself.\n Using .chezmoitemplates #  Files in the .chezmoitemplates subdirectory are parsed as templates and are available to be included in other templates using the template action with a name equal to their relative path to the .chezmoitemplates directory.\nBy default, such templates will be executed with nil data. If you want to access template variables (e.g. .chezmoi.os) in the template you must pass the data explicitly.\nFor example:\n.chezmoitemplates/part.tmpl: {{ if eq .chezmoi.os \u0026quot;linux\u0026quot; }} # linux config {{ else }} # non-linux config {{ end }} dot_file.tmpl: {{ template \u0026quot;part.tmpl\u0026quot; . }}  Using .chezmoitemplates for creating similar files #  When you have multiple similar files, but they aren\u0026rsquo;t quite the same, you can create a template file in the directory .chezmoitemplates. This template can be inserted in other template files, for example:\nCreate .local/share/chezmoi/.chezmoitemplates/alacritty:\nsome: config fontsize: {{ . }} more: config Notice the file name doesn\u0026rsquo;t have to end in .tmpl, as all files in the directory .chezmoitemplates are interpreted as templates.\nCreate other files using the template .local/share/chezmoi/small-font.yml.tmpl\n{{- template \u0026quot;alacritty\u0026quot; 12 -}} .local/share/chezmoi/big-font.yml.tmpl\n{{- template \u0026quot;alacritty\u0026quot; 18 -}} Here we\u0026rsquo;re calling the shared alacritty template with the font size as the . value passed in. You can test this with chezmoi cat:\n$ chezmoi cat ~/small-font.yml some: config fontsize: 12 more: config $ chezmoi cat ~/big-font.yml some: config fontsize: 18 more: config  Passing multiple arguments #  In the example above only one arguments is passed to the template. To pass more arguments to the template, you can do it in two ways.\n Via the config file #  This method is useful if you want to use the same template arguments multiple times, because you don\u0026rsquo;t specify the arguments every time. Instead you specify them in the file .config/chezmoi/.chezmoi.toml:\n[data.alacritty.big] fontsize = 18 font = \u0026#34;DejaVu Serif\u0026#34; [data.alacritty.small] fontsize = 12 font = \u0026#34;DejaVu Sans Mono\u0026#34; Use the variables in .local/share/chezmoi/.chezmoitemplates/alacritty:\nsome: config fontsize: {{ .fontsize }} font: {{ .font }} more: config And connect them with .local/share/chezmoi/small-font.yml.tmpl:\n{{- template \u0026quot;alacritty\u0026quot; .alacritty.small -}} At the moment, this means that you\u0026rsquo;ll have to duplicate the alacritty data in the config file on every machine, but a feature will be added to avoid this.\n By passing a dictionary #  Using the same alacritty configuration as above, you can pass the arguments to it with a dictionary, for example .local/share/chezmoi/small-font.yml.tmpl:\n{{- template \u0026quot;alacritty\u0026quot; dict \u0026quot;fontsize\u0026quot; 12 \u0026quot;font\u0026quot; \u0026quot;DejaVu Sans Mono\u0026quot; -}}  Useful templates #   Determine whether the current machine is a laptop or desktop #  The following template sets the $chassisType variable to \u0026quot;desktop\u0026quot; or \u0026quot;laptop\u0026quot; on macOS, Linux, and Windows.\n{{- $chassisType := \u0026quot;desktop\u0026quot; }} {{- if (eq .chezmoi.os \u0026quot;darwin\u0026quot;) }} {{- if contains \u0026quot;MacBook\u0026quot; (output \u0026quot;sysctl\u0026quot; \u0026quot;-n\u0026quot; \u0026quot;hw.model\u0026quot;) }} {{- $chassisType = \u0026quot;laptop\u0026quot; }} {{- else }} {{- $chassisType = \u0026quot;desktop\u0026quot; }} {{- end }} {{- else if (eq .chezmoi.os \u0026quot;linux\u0026quot;) }} {{- $chassisType = (output \u0026quot;hostnamectl\u0026quot; \u0026quot;--json=short\u0026quot; | mustFromJson).Chassis }} {{- else if (eq .chezmoi.os \u0026quot;windows\u0026quot;) }} {{- $chassisType = (output \u0026quot;powershell.exe\u0026quot; \u0026quot;-noprofile\u0026quot; \u0026quot;-command\u0026quot; \u0026quot;if (Get-WmiObject -Class win32_battery -ComputerName localhost) { echo laptop } else { echo desktop }\u0026quot;) }} {{- end }}  "}]